function P = sortConditions(P, FieldName, ParName, ParUnit, PlotScale);
% SortConditions - determine visiting order of stimulus conditions 
%   P = sortConditions(P, FieldName, ParName, ParUnit, PlotScale)
%   determines the visiting order of stimulus conditions for stimulus
%   parameter struct P and stores the result in P.
%   Input parameters are
%             P: struct containing the stimulus parameters as generated by
%                GUIval and further shaped by stimulus maker makestimFOO.
%                The following fields of P are used: Nrep, Order, RSeed,
%                Waveform, Fsam, and the field named <FieldName> (see below).
%     FieldName: field name of the varied parameter of P. Cellstring in
%                case of multiple varied parameters (2 max). It is assumed
%                that its values have been computed and are in a column 
%                vector or Nx2 array, whose elements are sorted in the 
%                'Forward' order by definition, and that the waveforms in
%                P.Waveform are in a on-to-one correspondence with these
%                parameter values. See makestimFS and makestimRF for
%                examples.
%       ParName: name of the varied parameter.
%       ParUnit: unit of the varied parameter.
%     PlotScale: 'lin' or 'log' when using the varied stimulus parameter as
%                along a plot axis (char string or cellstr). 'Octave' is
%                the same as 'log'. 
%
%    When two parameters are varied, all the input parameters except P
%    must be are 2-element cell strings. In this case, the visiting order
%    is delegated to EvalPresentationPanel_XY. For that to work, the field
%    P.Ncond_XY must be present, whose two elements are the number of 
%    different X and Y values, respectively. See makestimRF for an example.
%
%    The result is contained in a new field named 'Presentation' of P,
%    which is an StimPresentx object (see StimPresentx).
%
%    SortConditions is a helper function of stimulus-generating functions
%    such as makestimFS.
%
%    See also makestimFS, EvalStepper, StimPresentx, waveform/play.

% make all string arguments cell strings
[FieldName, ParName, ParUnit, PlotScale] ...
    = local_cellify(FieldName, ParName, ParUnit, PlotScale);
Nvar = numel(FieldName); % # varied stim params

% fill iCond and iRep arrays. Delegate to locals.
setRandState(P.RSeed);
[Ncond, Nchan] = size(P.Waveform);
if Nvar==1,
    [iCond, iRep] = local_visitOrder_X(Ncond, P.Nrep, P.Order, P.Grouping);
    Ncond_XY = [Ncond 1];
    Y = [];
elseif Nvar==2,
    Ncond_XY = P.Ncond_XY;
    Y = local_Xinfo(2, FieldName, ParName, ParUnit, PlotScale, P.(FieldName{2}), ParUnit{2}, Ncond_XY(2));
    [iCond, iRep] = local_visitOrder_XY(P, FieldName); 
else,
    error('A maximum of two stimulus parameters may be varied in a stimulus set.');
end
X = local_Xinfo(1, FieldName, ParName, ParUnit, PlotScale, P.(FieldName{1}), ParUnit{1}, Ncond_XY(1));

% The rest is bookkeeping, delegate to Stimpresentx
Npres = numel(iCond); 
Nrep = P.Nrep;
Nsample = NsamPlay(P.Waveform(:,1)); % played sample count of all waveforms in order of Waveform array

[P, NsamPre, NsamPost] = local_add_baselineWaveforms(P); % generate zero buffers for silent baseline intervals
P.Presentation = stimpresentx(P.Fsam, NsamPlay(P.Waveform), Ncond, Nrep, iCond, iRep, X, Y, [NsamPre, NsamPost]);
          
%==================================================
%==================================================

function varargout = local_cellify(varargin);
for iarg=1:nargin,
    x = varargin{iarg};
    if ischar(x), 
        x = {x}; 
    elseif iscellstr(x),
        if numel(x)>2,
            error(['A maximum of two values may be varied within a stimulus protocol.']);
        end
    end
    varargout{iarg} = x;
end


function X = local_Xinfo(ii, FieldName, ParName, ParUnit, PlotScale, Xval, Xunit, Nval);
if ii>numel(FieldName), X = []; return; end
[PlotVal, formatstring] = local_displayValues(Xval, Xunit);
X.ParName = ParName{ii};
X.PlotVal = PlotVal;
X.FormatString = formatstring;
X.FieldName = FieldName{ii};
X.ParUnit = ParUnit{ii};
X.PlotScale = PlotScale{ii};
X.Ncond = Nval;

function [x, f] = local_displayValues(X, Unit);
if isempty(X), 
    x = []; f = ''; return; 
elseif size(X,2)==1, 
    x = X; 
else, % take most interesting channel, showing max variance
    [dum, ichan] = max(var(X)); 
    x = X(:,ichan);
end
if isscalar(x), maxDX = 0.001*abs(x);
else, maxDX = max(abs(diff(x)));
end
if isempty(maxDX), maxDX = 0; end
if all(x==round(x)) || maxDX>=1, 
    f = '%.0f';
elseif maxDX>0,
    f = ['%.' num2str(ceil(-2*log10(maxDX))) 'f'];
else, 
    f = '%f';
end
f = [f ' ' Unit];

function [P, NsamPre, NsamPost] = local_add_baselineWaveforms(P);
NsamBlock = 10000; % default size of waveform block
ManyZeros = zeros(NsamBlock,1);
[NsamPre, NsamPost] = dealelements(round(P.Baseline([1 end])*P.Fsam/1e3));
NsamPre = max(NsamPre,2); % at least two samples to avoid ... 
NsamPost = max(NsamPost,2);  % ... handling special case of empty baseline
Ncond = size(P.Waveform,1); % # stim conditions
% pre
[Nrem Nrep Ncorr] = local_bufsize(NsamPre, NsamBlock);
NsamPre = NsamPre+Ncorr;
FewZeros = zeros(Nrem,1);
for ichan=1:size(P.Waveform,2),
    if Nrem+Nrep==0, P.Waveform(Ncond+1, ichan) = waveform; % no baseline interval: insert void waveform
    else,
        x = P.Waveform(1, ichan); % example waveform
        P.Waveform(Ncond+1, ichan) = waveform(x.Fsam, x.DAchan, 0, -100, struct([]), {ManyZeros, FewZeros}, [Nrep 1]);
    end
end
% post
[Nrem Nrep Ncorr] = local_bufsize(NsamPost, NsamBlock);
NsamPost = NsamPost+Ncorr;
FewZeros = zeros(Nrem,1);
for ichan=1:size(P.Waveform,2),
    if Nrem+Nrep==0, P.Waveform(Ncond+2, ichan) = waveform; % no baseline interval: insert void waveform
    else,
        x = P.Waveform(1, ichan); % example waveform
        P.Waveform(Ncond+2, ichan) = waveform(x.Fsam, x.DAchan, 0, -100, struct([]), {ManyZeros, FewZeros}, [Nrep 1]);
    end
end


function [Nrem Nrep Ncorr] = local_bufsize(Nsamplay, NsamBlock);
Ncorr = 0;
Nrep = floor(Nsamplay/NsamBlock);
Nrem = rem(Nsamplay, NsamBlock);
if Nrem<2, % make sure rem buffer is not too short 
    Ncorr = 2-Nrem;
    Nrem=2; 
end

function  [iCond, iRep] = local_visitOrder_X(Ncond, Nrep, Order, Grouping);
% determine visiting order. Single varied param.
switch [Order '/' Grouping],
    case 'Forward/rep by rep', % a b c  a b c
        iCond = repmat((1:Ncond)',Nrep,1);
    case 'Forward/by condition', % a a  b b  c c
        iCond = ones(Nrep,1)*(1:Ncond);
        iCond = iCond(:);
    case 'Reverse/rep by rep', % a b c  a b c
        iCond = repmat((Ncond:-1:1)',Nrep,1);
    case 'Reverse/by condition', % a a  b b  c c
        iCond = ones(Nrep,1)*(Ncond:-1:1);
        iCond = iCond(:);
    case 'Random/rep by rep', % c a b  c a b
        iCond = repmat(randperm(Ncond)',Nrep,1);
    case {'Random/by condition', 'Scrambled/by condition'}, % c c  a a  b b
        iCond = ones(Nrep,1)*randperm(Ncond);
        iCond = iCond(:);
    case 'Scrambled/rep by rep', % c a b  b c a
        iCond = [];
        for irep=1:Nrep, iCond = [iCond; randperm(Ncond)']; end
    otherwise,
        error(['Invalid Order/Grouping combination ''' [Order '/' Grouping] '''.']);
end
% sort iRep using a matrix trick
iRep = ones(Ncond,1)*(1:Nrep); % columns=reps; rows=conditions
if isequal('rep by rep', Grouping),
elseif isequal('by condition', Grouping),
    iRep = iRep.';
else, error(['Invalid stimulus grouping ''' Grouping '''.']);
end
iRep = iRep(:);

function [iCond, iRep] = local_visitOrder_XY(P, FN);
% just call EvalPresentationPanel_XY and
VO = EvalPresentationPanel_XY(nan, P, P.Ncond_XY);
iCond = VO.iCond(:);
iRep = VO.iRep(:);



