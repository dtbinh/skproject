function ArgOut = SBCmodel(varargin)
%SBCMODEL   generate spiketrain based on simple model of a Spherical Bushy Cell
%   Spk = SBCMODEL(Spk1, Spk2, ..., Spkn) calculates a spiketrain generated by a 
%   modelled Spherical Bushy cell. The model simulates an SBC with all supra-threshold
%   inputs and with a variable refractory period.
%
%   Repetitions of a nerve input can be given as cell-arrays. The number of repetitions
%   should be the same for all inputs, otherwise the number is reduced so all repetition-
%   numbers are the same. Output will then be a cell-array containing spike-time vectors
%   with the same number of repetitions.
%
%   If only one input is given with an even repetition number, then the input for the model
%   is interpreted as coming from two inputs with each half of the repetition numbers. An 
%   interlaced distribution of the repetitions over the two inputs is used to compensate for
%   drift.
%
%   Optional properties and their values can be given as a comma-separated list. To view list
%   of all possible properties and their default value, use 'factory' as only argument.

%B. Van de Sande 17-03-2004

%-----------------------------default parameters-----------------------------
DefParam.refrac   = 0.75;        %Refractory period in ms ...
DefParam.anwin    = [0 +Inf];    %Analysis window in ms ...
DefParam.diag     = 'off';       %Display diagnostics 'on' or 'off' ...
DefParam.antype   = 'ac';        %Analysis type can be 'prd' (period histogram) or 'ac' (autocorrelogram) ...
DefParam.maxlag   = 10;          %Maximum lag in ms for autocorrelograms ...
DefParam.binwidth = 0.05;        %Binwitdh for autocorrelograms in ms ...
DefParam.binfreq  = 350;         %Binning frequency for period histograms ...
DefParam.nbin     = 64;          %Number of bins for period histograms ...

%--------------------------------main program--------------------------------
%Checking input parameters ...
[Param, Spk] = ParseArgs(DefParam, varargin{:});
if isempty(Param), return; end
%Actual calculation ...
[SpkOut, SpkIn] = CalcSpk(Param, Spk{:});
%Display diagnostics if requested ...
if strcmpi(Param.diag, 'on'), PlotDiag(Param, SpkIn, SpkOut); end

if (length(SpkOut) == 1), ArgOut = SpkOut{1};
else, ArgOut = SpkOut; end

%-----------------------------local functions--------------------------------
function [Param, SpkIn] = ParseArgs(DefParam, varargin)

Param = struct([]); SpkIn = cell(0);

if (length(varargin) == 1) & ischar(varargin{1}) & strcmpi(varargin{1}, 'factory'),
    disp('Properties and their factory defaults are:');
    disp(DefParam);
    return;
end

Pidx = min(find(cellfun('isclass', varargin, 'char')));
if isempty(Pidx), Pidx = length(varargin)+1; end
    
Cidx = find(cellfun('isclass', varargin, 'cell'));
Didx = find(cellfun('isclass', varargin, 'double')); Didx(find(Didx > Pidx)) = [];
Tidx = sort([Cidx, Didx]);
if ~isequal(Tidx, 1:Pidx-1), error('Wrong input arguments.'); end
SpkIn = varargin(Tidx);

if ~all(cellfun('size', SpkIn(Didx), 1) == 1), error('Wrong input arguments.'); end
for n = 1:length(Didx), SpkIn(n) = {SpkIn(n)}; end

for n = 1:length(Cidx), if ~all(cellfun('isclass', SpkIn{n}, 'double')), error('Wrong input arguments.'); end; end

Param = checkproplist(DefParam, varargin{Pidx:end});
if ~isnumeric(Param.refrac) | (length(Param.refrac) ~= 1) | (Param.refrac <= 0), error('Invalid value for property refrac'); end
if ~isnumeric(Param.anwin) | (length(Param.anwin) ~= 2) | (Param.anwin(1) < 0) | (Param.anwin(1) > Param.anwin(2)), error('Invalid value for property anwin.'); end
if ~ischar(Param.diag) | ~strcmpi(Param.diag, {'on', 'off'}), error('Invalid value for property diag.'); end
if ~ischar(Param.antype) | ~strcmpi(Param.antype, {'prd', 'ac'}), error('Invalid value for property antype.'); end
if ~isnumeric(Param.maxlag) | (length(Param.maxlag) ~= 1) | (Param.maxlag <= 0), error('Invalid value for property maxlag.'); end
if ~isnumeric(Param.binwidth) | (length(Param.binwidth) ~= 1) | (Param.binwidth <= 0), error('Invalid value for property binwidth.'); end
if ~isnumeric(Param.binfreq) | (length(Param.binfreq) ~= 1) | (Param.binfreq <= 0), error('Invalid value for property binfreq.'); end
if ~isnumeric(Param.nbin) | (length(Param.nbin) ~= 1) | (Param.nbin <= 0), error('Invalid value for property nbin.'); end

%----------------------------------------------------------------------------
function [SpkOut, SpkIn] = CalcSpk(Param, varargin)

NInputs = nargin-1;
Spk     = varargin;

%Applying analysis window on all input spiketrains ...
for n = 1:NInputs, Spk(n) = anwin(Spk(n), Param.anwin); end

%Reducing the number of repetitions per input spiketrain so they are all equal
%for the different inputs and at the same time reorganize the input spiketrains.
%The input spiketrains are represented by a cell-array, with in every row a
%different spiketrain and in every column a different repetition number ...
if (NInputs ~= 1),
    NReps = cellfun('length', Spk);
    if (length(unique(NReps)) ~= 1),
        warning(sprintf('Number of repetitions aren''t equal for different inputs. Reducing\nthe number of repetitions.'));
    end
    NReps = min(NReps); SpkIn = cell(NInputs, NReps);
    for n = 1:NInputs, SpkIn(n, :) = Spk{n}(1:NReps); end
%If only one input spiketrain is given then two different input spiketrains are 
%generated, the first one with all the even repetition numbers and the second with
%all the odd numbers ...
else,
    NReps = length(Spk{1});
    if (mod(NReps, 2) ~= 0), 
        warning(sprintf('Number of repetitions is not an even number. Reducing the\nnumber of repetitions.'));
    end
    NReps = 2*floor(NReps/2);
    SpkIn(1, :) = Spk{1}(1:2:NReps);
    SpkIn(2, :) = Spk{1}(2:2:NReps);
    NReps = NReps/2;
end 

%Summing the different spiketrains and checking the refractory period on the newly 
%created spiktrains ...
SpkOut = cell(1, NReps);
for n = 1:NReps, 
    OldSpkTrain = sort(cat(2, SpkIn{:, n})); 
    if isempty(OldSpkTrain), SpkOut{n} = [];
    else,    
        NSpks       = length(OldSpkTrain);
        Intervals   = diff(OldSpkTrain);
        NewSpkTrain = OldSpkTrain(1);
        idx = 1;
        while 1,
            %Using cumulative intervals, the interval between the next spike and the 
            %following is equal or larger than the refractory period ...
            newidx = min(find(cumsum(Intervals(idx:end)) >= Param.refrac));
            if isempty(newidx), break; end
            idx = idx + newidx;
            NewSpkTrain = [NewSpkTrain, OldSpkTrain(idx)];
        end    
        
        SpkOut{n} = NewSpkTrain;
    end
end

%----------------------------------------------------------------------------
function PlotDiag(Param, SpkIn, SpkOut)

FigHdl = figure('Name', 'SBC Model Diagnostics', ...
    'Units', 'normalized', ...
    'NumberTitle', 'off', ...
    'PaperType', 'A4', ...
    'PaperPositionMode', 'manual', ...
    'PaperUnits', 'normalized', ...
    'PaperPosition', [0.05 0.05 0.90 0.90], ...
    'PaperOrientation', 'landscape');

UpperMargin  = 0.08;
LowerMargin  = 0.08;
VerAxSpacing = 0.08;
LeftMargin   = 0.08;
RightMargin  = 0.05;
HorAxSpacing = 0.08;

NInputs = size(SpkIn, 1);
NY = NInputs + 1;
AxHeight = (1 -UpperMargin -LowerMargin -(NY-1)*VerAxSpacing)/NY;
RasWidth = (1 -LeftMargin -RightMargin -HorAxSpacing)*2/3;
AnWidth  = (1 -LeftMargin -RightMargin -HorAxSpacing)*1/3;

%Plotting spike rasters for inputs ...
NRas = size(SpkIn, 1);
for n = 1:NRas, 
    AxY = LowerMargin + (n-1)*(AxHeight + VerAxSpacing);
    AxHdl(n) = PlotRaster(SpkIn(n, :), [LeftMargin, AxY, RasWidth, AxHeight], [0.7 0.7 0.7], sprintf('IN %d', n));
    set(AxHdl(n), 'XLim', Param.anwin);
end

%Plotting spike rasters for output ...
AxY = LowerMargin + NRas*(AxHeight + VerAxSpacing);
AxHdl(end+1) = PlotRaster(SpkOut, [LeftMargin, AxY, RasWidth, AxHeight], [0.5 0.5 0.5], 'OUT'); 
title('SPIKE RASTERS', 'FontSize', 12);

%Plotting analysis plots ...
AxHdl = [];
if strcmpi(Param.antype, 'ac'), %Autocorrelograms ...
    NRas = size(SpkIn, 1);
    AxX = LeftMargin + RasWidth + VerAxSpacing;
    for n = 1:NRas, 
        AxY = LowerMargin + (n-1)*(AxHeight + VerAxSpacing);
        AxHdl(n) = PlotAutoCorr(SpkIn(n, :), Param, [AxX, AxY, AnWidth, AxHeight], 'b'); 
    end
    
    AxY = LowerMargin + NRas*(AxHeight + VerAxSpacing);
    AxHdl(end+1) = PlotAutoCorr(SpkOut, Param, [AxX, AxY, AnWidth, AxHeight], 'r'); 
    title('AUTOCORRELOGRAMS', 'FontSize', 12);
    YLim = get(AxHdl, 'YLim'); YLim = cat(1, YLim{:}); 
    set(AxHdl, 'YLim', [0, max(YLim(:, 2))]);
    for n = 1:(NRas+1), 
        axes(AxHdl(n));
        LnHdl(n) = line([0 0], ylim, 'LineStyle', ':', 'Color', 'k', 'Marker', 'none');
    end
else, %Period histograms ...
    NRas = size(SpkIn, 1);
    AxX = LeftMargin + RasWidth + VerAxSpacing;
    for n = 1:NRas, 
        AxY = LowerMargin + (n-1)*(AxHeight + VerAxSpacing);
        AxHdl(n) = PlotPrdHist(SpkIn(n, :), Param, [AxX, AxY, AnWidth, AxHeight]); 
    end
    
    AxY = LowerMargin + NRas*(AxHeight + VerAxSpacing);
    AxHdl(end+1) = PlotPrdHist(SpkOut, Param, [AxX, AxY, AnWidth, AxHeight]); 
    title('PERIOD HISTOGRAMS', 'FontSize', 12);
    YLim = get(AxHdl, 'YLim'); YLim = cat(1, YLim{:}); 
    set(AxHdl, 'YLim', [0, max(YLim(:, 2))]);
end    

%----------------------------------------------------------------------------
function AxHdl = PlotRaster(Spks, Pos, Col, YLbl)

AxHdl = axes('Position', Pos, 'TickDir', 'out', 'Box', 'on');

NRep = length(Spks); X = []; Y = [];
YStart = linspace(0.025, 0.975, NRep+1); 
YTicks = YStart(1:end-1) + diff(YStart([1, 2]))/2;
for n = 1:NRep,
    SpkTr = Spks{n}; NSpk = length(SpkTr);
    if (NSpk > 0),
        X  = [X vectorzip(SpkTr, SpkTr, repmat(NaN, 1, NSpk))];
        y1 = YStart(n) + zeros(1, NSpk); y2 = YStart(n+1) + zeros(1, NSpk);
        Y  = [Y, vectorzip(y1, y2, y2)];
    end
end
LnHdl = line(X, Y, 'LineStyle', '-', 'Color', Col, 'Marker', 'none');

set(AxHdl, 'YTick', YTicks, 'YTickLabel', 1:NRep, 'YLim', [0 1], 'YLabel', ylabel(YLbl));
set(AxHdl, 'XLabel', xlabel('Time (ms)'));

%----------------------------------------------------------------------------
function AxHdl = PlotAutoCorr(Spks, Param, Pos, Col)

AnWin = Param.anwin; if isinf(AnWin(2)), AnWin(2) = max(cat(2, Spks{:})); end

[c, t, N] = sptcorr(Spks, 'nodiag', Param.maxlag, Param.binwidth, diff(AnWin)); c = c/N.DriesNorm;
PkHeight = max(c); HalfHeight = ((max(c)-min(c))/2)+min(c);
HHWx     = cintersect(t, c, HalfHeight);
HHW      = abs(diff(HHWx));

AxHdl = axes('Position', Pos, 'TickDir', 'in', 'Box', 'on');
LnHdl(1) = line(t, c, 'LineStyle', '-', 'Color', Col, 'Marker', 'none');
lnHdl(2) = line(HHWx, HalfHeight([1 1]), 'LineStyle', '-', 'Color', 'k', 'Marker', 'none');
xlabel('Delay (ms)'); ylabel('Coincidences (Norm)');
text(1, 1, {sprintf('PkHeight = %.2f', PkHeight), sprintf('HHW = %.2f', HHW)}, 'Units', 'normalized', 'VerticalAlignment', 'top', 'HorizontalAlignment', 'right');

%----------------------------------------------------------------------------
function AxHdl = PlotPrdHist(Spks, Param, Pos)

%Calculate period histograms ...
AnWin  = Param.anwin; if isinf(AnWin(2)), AnWin(2) = max(cat(2, Spks{:})); end
Period = 1000/Param.binfreq;
NPrds  = abs(diff(AnWin))/Period;

NRep   = length(Spks);
Spks = cat(2, Spks{:}); NSpk = length(Spks);

Spks = rem(Spks, Period)/Period;
Edges = linspace(0, 1, Param.nbin+1); 
BinWidth = Edges(2)-Edges(1);
BinCenters = Edges(2:end)-0.5*BinWidth;
if isempty(Spks), Spks = Inf; end;
N = histc(Spks, Edges); N = N(1:end-1);
BinDur = BinWidth*Period/1000;
Rate = N/NRep/NPrds/BinDur;

%Extract parameters ...
Ph = BinCenters*2*pi;
X = sum(N.*cos(Ph)); Y = sum(N.*sin(Ph));
if isequal(NSpk, 0), R = NaN; else, R = sqrt(X^2+Y^2)/NSpk; end
RaySig = RayleighSign(R, NSpk);

%Plot period histograms ...
AxHdl = axes('Position', Pos, 'TickDir', 'in', 'Box', 'on');
HistHdl = bar(BinCenters, Rate, 1);
set(HistHdl, 'FaceColor', [0.7 0.7 0.7], 'EdgeColor', [0.7 0.7 0.7]);
xlabel('Cycles'); ylabel('Rate (Spk/sec)');
text(1, 1, {sprintf('R = %.3f', R), sprintf('RaySig = %.3f', RaySig)}, 'Units', 'normalized', 'VerticalAlignment', 'top', 'HorizontalAlignment', 'right');

%----------------------------------------------------------------------------