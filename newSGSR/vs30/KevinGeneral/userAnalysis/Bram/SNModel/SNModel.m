function SpkOut = SNModel(Param, varargin)
%SNMODEL    shot-noise coincidence model.
%   SpkOut = SNMODEL(P, Spk1, Spk2, ..., SpkN) calculates an
%   output spiketrain generated by a shot-noise coincidence
%   model. The parameters of the model are set via a scalar
%   structure P and are:
%       P.anwin    : analysis window in ms.
%       P.ninputs  : number of inputs.
%       P.ainputs  : amplitude of the inputs given as a scalar
%                    or a rowvector with the same length as the
%                    number of inputs.
%       P.trefrac  : refractory period in ms.
%       P.tdecay   : decay period of input amplitude in ms.
%       P.thr      : threshold level.
%       P.repmode  : handling of repetitions of an input: calculate
%                    all permutations ('all') or only perform pairwise 
%                    calculation ('pair').
%       P.maxnperm : maximum number of permutations when repetitions
%                    are present.
%   The actual spiketrain inputs for the model must be given
%   as numerical rowvectors or as cell-arrays of rowvectors.
%   The different elements of a cell-array are interpreted as
%   repetition of the same input fiber.
%
%   See also SNMODELMEX

%B. Van de Sande 13-08-2004
%Two implemenations of the model are developed: a slow MATLAB version (SNMODELSLOW.M) and
%a fast C MEX version (SNMODELMEX.C and SNMODELMEX.DLL) ...

%Default parameters ...
DefParam.anwin    = [0 Inf]; %Analysis window in ms ...
DefParam.ninputs  = 2;       %Number of inputs ...
DefParam.ainputs  = 0.90;    %Amplitude of the inputs given as a scalar or 
                             %a rowvector with the same length as the number
                             %of inputs ...
DefParam.trefrac  = 0.800;   %Refractory period in ms ...
DefParam.tdecay   = 0.700;   %Decay period of input amplitude in ms ...
DefParam.thr      = 1;       %Threshold level ...
DefParam.repmode  = 'all';   %Handling of repetitions: 'all' or 'pair' ...
DefParam.maxnperm = 1e3;     %Maximum number of permutations ...

%Checking input arguments ...
if (nargin < 1), error('Wrong number of input arguments.'); end
if ~isstruct(Param) | ~all(ismember(fieldnames(Param), fieldnames(DefParam))),
    error('First argument should be scalar structure with model parameters.');
else, Param = CheckPropList(DefParam, Param); Param = CheckParam(Param); end
if ((nargin-1) ~= Param.ninputs), error('Wrong number of input spiketrains for model.')
else, Inputs = reshape(varargin, 1, Param.ninputs); end

%Only application of the analysis window and the handling of permutations is done
%in MATLAB, the actual calculations for the model are done via a MEX function ...
for n = 1:Param.ninputs, Inputs{n} = anwin(Inputs{n}, Param.anwin); end %Applying analysis window ...
if any(cellfun('isclass', Inputs, 'cell')),
    if strcmpi(Param.repmode, 'all'), %Calculate all permutations ...
        Nreps = cellfun('length', Inputs); Nperms = prod(Nreps);
        if (Nperms > Param.maxnperm), Nperms = Param.maxnperm; Perms = genrandperms(Nreps, Nperms);
        else, Perms = genperms(Nreps); end
        SpkOut = cell(1, Nperms);
        for n = 1:Nperms,
            for i = 1:Param.ninputs, Args{i} = Inputs{i}{Perms(n, i)}; end
            SpkOut{n} = SNModelMEX(Param, Args{:});
        end
    else, %Calculate pairwise combinations of repetitions ...
        Nreps = cellfun('length', Inputs); Nrep = max(Nreps);
        if ~all(ismember(Nreps, [1, Nrep])), error('Wrong number of repetitions for pairwise combination.'); end
        for idx = find(Nreps == 1), Inputs(idx) = repmat(Inputs(idx), 1, Nrep); end
        SpkOut = cell(1, Nrep);
        for n = 1:Nrep,
            for i = 1:Param.ninputs, Args{i} = Inputs{i}{n}; end
            SpkOut{n} = SNModelMEX(Param, Args{:});
        end
    end
else, SpkOut = SNModelMEX(Param, Inputs{:}); end %Calling MEX-function ...

%-----------------------------local functions-------------------------
function Param = CheckParam(Param)

if ~isnumeric(Param.anwin) | (length(Param.anwin) ~= 2) | any(Param.anwin < 0) | (diff(Param.anwin) <= 0), error('Invalid value for property ninputs.');
else, Param.anwin = reshape(Param.anwin, 1, 2); end
if ~isnumeric(Param.ninputs) | (length(Param.ninputs) ~= 1) | (Param.ninputs < 0) | mod(Param.ninputs, 1), error('Invalid value for property ninputs.'); end
if ~isnumeric(Param.ainputs) | ~any(length(Param.ainputs) == [1, Param.ninputs]), error('Invalid value for property ainputs.');
elseif (length(Param.ainputs) == 1), Param.ainputs = repmat(Param.ainputs, 1, Param.ninputs);
else, Param.ainputs = reshape(Param.ainputs, 1, Param.ninputs); end
if ~isnumeric(Param.trefrac) | (length(Param.trefrac) ~= 1) | (Param.trefrac < 0), error('Invalid value for property trefrac.'); end
if ~isnumeric(Param.tdecay) | (length(Param.tdecay) ~= 1) | (Param.tdecay <= 0), error('Invalid value for property tdecay.'); end
if ~isnumeric(Param.thr) | (length(Param.thr) ~= 1) | (Param.thr <= 0), error('Invalid value for property thr.'); end
if ~ischar(Param.repmode) | ~any(strcmpi(Param.repmode, {'all', 'pair'})), error('Invalid value for property repmode.'); end
if ~isnumeric(Param.maxnperm) | (length(Param.maxnperm) ~= 1) | (Param.maxnperm < 0) | mod(Param.maxnperm, 1), error('Invalid value for property maxnperm.'); end

%---------------------------------------------------------------------