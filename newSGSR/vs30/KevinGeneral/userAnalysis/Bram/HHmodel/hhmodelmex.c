#include <math.h>
#include <stdlib.h>
#include <string.h>
#include "mexutils.h"

/*MEX implementation of a Bushy cell based on the Hodgkin and Huxley membrane 
potential equations. The model is an adendretic, anaxonal and single compartment 
model.

SpkOut = HHMODELMEX(P, SpkIn1, SpkIn2, ..., SpkInN) calculates a spiketrain 
generated by a modelled Bushy cell. The model must be defined by the structure P.
The spiketrains inputs, recorded from the auditory nerve (AN), must be supplied
as numerical rowvectors. The number of inputs must be defined in the struct P.

[SpkOut, t, V] = HHMODELMEX(P, SpkIn1, SpkIn2, ..., SpkInN) also returns the
mebrane potential as a function of time.

List of parameters that can be changed in the model and their associated fieldnames:
   tc  : ambient temperature in degrees celsius
   cs  : membrane capacitance in pico Farraday

   ne  : number of excitatory inputs
   ae  : conductance strength for excitatory inputs in nano Sievert
   de  : delay in conductance strength peak in ms

   ep  : equilibrium membrane potential for potassium ions in mV
   es  : equilibrium membrane potential for sodium ions in mV
   el  : equilibrium membrane potential for leakage ions in mV
   ee  : equilibrium membrane potential for ions that are associated with an
         excitatory synaps

   th  : spiketime threshold membrane potential in mV
   v0  : starting membrane potential in mV
   aw  : analysis window in ms
All parameters must be set to a scalar value, except the analysis window and
the conductance strength of excitatory inputs. The analysis window must be defined
as a two element vector. The conductance strength must be supplied as a vector with
the same number of inputs to the model. The excitatory synaptic conductances can be
divided into three rough categories: subthreshold conductances (ae < 16 nS) that do
not produce spike outputs when presented alone; near-threshold conductances 
(16 <= Ae <= 40 nS) and suprathreshold conductances.*/

/*Based on JASON S. ROTHMAN, ERIC D. YOUNG, PAUL B. MANIS, "Convergence of Auditory
Nerve Fibers Onto Bushy Cells in the Ventral Cochlear Nucleus: Implications of a 
Computational Model", JOURNAL OF NEUROPHYSIOLOGY Vol.70, No. 6, December 1993*/

/*---------------------------------ODESolve--------------------------------------*/
void ODEIntegratorRK5(void (*f)(double, double*, double*, void*), long neq,
    double x, double* y, double* dydx, double h, double* yout, double* yerr, 
    void* varargs);
/*Integrates the supplied ODE set f with number of equations neq from value x with
values y and derivates dydx up to x+h using a fifth order embedded Runga-Kutta method.
The values in x+h are returned in yout and the absolute error on these values in yerr.*/
    
void ODEStepper(void (*f)(double, double*, double*, void*), long neq, 
    double* x, double* y, double* dydx, double hreq, double* hdid, double* hnext,
    double eps, double* yscal, void* varargs);
/*Integrates the supplied ODE set f with number of equations neq from value x with
values y and derivates dydx up to x+hreq with a requested accuracy specified by eps and
yscal. The actual step taken is hdid and the value of x is changed to x+hdid An
estimation of the next step size is returned in hnext.*/
    
void ODESolve(void (*f)(double, double*, double*, void*), long neq, double* y0,
    double x1, double x2, double eps, double h1, double hmin, Vector* xout, 
    Vector* yout, void* varargs);
/*Integrates the supplied ODE set f with number of equations neq from value x1 to x2 with
starting values y0 at x1 requested relative accuracy specified by eps. hmin is the minimal
stepsize that can be taken by the integrator to achieve the desired accuracy. h1 is an
estimation of the first stepsize.*/

/*------------------------------------MEX---------------------------------------*/
double*  GetRowVectorField(mxArray *S, char* FieldName, long N);
double   GetScalarField(mxArray *S, char* FieldName);
Vector*  GetSpkIn(mxArray* Args[], long N);

/*---------------------------------HHModel---------------------------------------*/
typedef struct{
    double Tc;    /*Ambient temperature in degrees celsius*/
    double Cs;    /*Membrane capacitance in pico Farraday*/
    double *Ae;   /*Conductance strength for excitatory inputs in nano Sievert*/
    double De;    /*Delay in conductance strength peak in ms*/
    long   Ne;    /*Number of excitatory inputs*/
    double Ep;    /*Equilibrium membrane potential for potassium ions in mV*/
    double Es;    /*Equilibrium membrane potential for sodium ions in mV*/
    double El;    /*Equilibrium membrane potential for leakage ions in mV*/
    double Ee;    /*Equilibrium membrane potential for ions that are associated with
                    an excitatory synaps*/
    double Th;    /*Spiketime threshold membrane potential in mV*/
    double V0;    /*Starting membrane potential in mV*/
    double *aw;   /*Analysis window in ms*/
}MdlParam; /*Structure with all model parameters*/

MdlParam GetMdlParam(mxArray* S);

typedef struct{
    double   De, Cs, Ep, Es, El, Ee;
    long     Nspk;
    double   *Spks, *Gspk;
    double   Tc2, Tc2_5, Tc3, Tc10;
} MdlData;

double CorrectT(double cf, double T);
MdlData MdlDataInit(MdlParam P, Vector* SpkIn);
void MdlDataFree(MdlData D);

Vector V2Spk(double Th, Vector t, Vector Vmem);

void HHODE(double t, double* f, double* dfdt, void* varargs);
void HHModel(MdlParam P, Vector* SpkIn, Vector* SpkOut, Vector* t, Vector* V);
               
/*----------------------------MEX Interface--------------------------------------*/
void mexFunction(int nlhs,       mxArray* plhs[],
                 int nrhs, const mxArray* prhs[])
{
    MdlParam P; Vector* SpkIn; 
    Vector SpkOut = {0, 0, NULL}; Vector t = {0, 0, NULL}; Vector V = {0, 0, NULL};
    long i;

    /*Check input arguments and retrieve model parameters*/
    if (nrhs == 0) mexErrMsgTxt("Wrong number of input arguments.");
    else if (!mxIsStruct(prhs[0]) || (mxGetNumberOfElements(prhs[0]) != 1))
        mexErrMsgTxt("First argument should be scalar structure with model parameters.");
    else P = GetMdlParam(prhs[0]);
    
    if (P.Ne != (nrhs-1)) mexErrMsgTxt("Wrong number of input spiketrains.");
    if (P.Ne == 0) /*Nothing to be done*/
    { 
        nlhs = 3; for (i = 0; i < nlhs; i++) plhs[i] = mxCreateDoubleMatrix(0, 0, mxREAL);
    }
    else 
    {   
        /*Get input spiketrains*/
        SpkIn = GetSpkIn(prhs+1, P.Ne);
        
        /*Peform actual calculations*/
        HHModel(P, SpkIn, &SpkOut, &t, &V);
    
        /*Create output arguments*/
        nlhs = 3; 
        plhs[0] = Vector2mxArray(SpkOut); plhs[1] = Vector2mxArray(t); plhs[2] = Vector2mxArray(V);
    
        /*Free dynamic memory*/
        for (i = 0; i < P.Ne; i++) VectorFree(SpkIn+i); mxFree(SpkIn);
        VectorFree(&SpkOut); VectorFree(&t); VectorFree(&V);
    }    
}

/*-------------------------------------------------------------------------------*/
#define ODE_SAFETY   0.9
#define ODE_PGROW    -0.2
#define ODE_PSHRNK   -0.25
#define ODE_ERRCON   1.89e-4
#define ODE_MAXSTP   1e6
#define ODE_TINY    1.0e-30
#define SIGN(a,b)   ((b) >= 0.0 ? fabs(a) : -fabs(a))
#define DMAX(a,b)   ((a<b)?b:a)
#define DMIN(a,b)   ((a<b)?a:b)

void ODEIntegratorRK5(void (*f)(double, double*, double*, void*), long neq,
    double x, double* y, double* dydx, double h, double* yout, double* yerr, 
    void* varargs)
/*Integrates the supplied ODE set f with number of equations neq from value x with
values y and derivates dydx up to x+h using a fifth order embedded Runga-Kutta method.
The values in x+h are returned in yout and the absolute error on these values in yerr.*/
{
    /*Cash-Karp parameter table for embedded Runga-Kutta method*/
	static double 
	                                                                                                                          c1 = 37.0/378.0,
	    a2 = 0.2,   b21 = 0.2,                                                                                                
	    a3 = 0.3,   b31 = 3.0/40.0,       b32 = 9.0/40.0,                                                                     c3 = 250.0/621.0,
	    a4 = 0.6,   b41 = 0.3,            b42 = -0.9,        b43 = 1.2,                                                       c4 = 125.0/594.0,
	    a5 = 1.0,   b51 = -11.0/54.0,     b52 = 2.5,         b53 = -70.0/27.0,    b54 = 35.0/27.0,                            
	    a6 = 0.875, b61 = 1631.0/55296.0, b62 = 175.0/512.0, b63 = 575.0/13824.0, b64 = 44275.0/110592.0, b65 = 253.0/4096.0, c6 = 512.0/1771.0;
	double dc1 = c1-2825.0/27648.0, dc3 = c3 - 18575.0/48384.0, dc4 = c4 - 13525.0/55296.0, dc5 = -277.00/14336.0, dc6 = c6 - 0.25;
		
	double *k2, *k3, *k4, *k5, *k6, *ytmp;
    long i;

	k2   = (double*)mxMalloc(neq*sizeof(double));
	k3   = (double*)mxMalloc(neq*sizeof(double));
	k4   = (double*)mxMalloc(neq*sizeof(double));
	k5   = (double*)mxMalloc(neq*sizeof(double));
	k6   = (double*)mxMalloc(neq*sizeof(double));
	ytmp = (double*)mxMalloc(neq*sizeof(double));
	
	for (i = 0; i < neq; i++) ytmp[i] = y[i]+b21*h*dydx[i];
	(*f)(x+a2*h, ytmp, k2, varargs);
	for (i = 0; i < neq; i++) ytmp[i] = y[i]+h*(b31*dydx[i]+b32*k2[i]);
	(*f)(x+a3*h, ytmp, k3, varargs);
	for (i = 0; i < neq; i++) ytmp[i] = y[i]+h*(b41*dydx[i]+b42*k2[i]+b43*k3[i]);
	(*f)(x+a4*h, ytmp, k4, varargs);
	for (i = 0; i < neq; i++) ytmp[i] = y[i]+h*(b51*dydx[i]+b52*k2[i]+b53*k3[i]+b54*k4[i]);
	(*f)(x+a5*h, ytmp, k5, varargs);
	for (i = 0; i < neq; i++) ytmp[i] = y[i]+h*(b61*dydx[i]+b62*k2[i]+b63*k3[i]+b64*k4[i]+b65*k5[i]);
	(*f)(x+a6*h, ytmp, k6, varargs);
	for (i = 0; i < neq; i++) yout[i]  = y[i]+h*(c1*dydx[i]+c3*k3[i]+c4*k4[i]+c6*k6[i]);
	for (i = 0; i < neq; i++) yerr[i]  = h*(dc1*dydx[i]+dc3*k3[i]+dc4*k4[i]+dc5*k5[i]+dc6*k6[i]);
	
	mxFree(ytmp);
	mxFree(k6);
	mxFree(k5);
	mxFree(k4);
	mxFree(k3);
	mxFree(k2);
}

void ODEStepper(void (*f)(double, double*, double*, void*), long neq, 
    double* x, double* y, double* dydx, double hreq, double* hdid, double* hnext,
    double eps, double* yscal, void* varargs)
/*Integrates the supplied ODE set f with number of equations neq from value x with
values y and derivates dydx up to x+hreq with a requested accuracy specified by eps and
yscal. The actual step taken is hdid and the value of x is changed to x+hdid An
estimation of the next step size is returned in hnext.*/   
{
    double errmax, h = hreq, htemp, xnew;
    double *yerr, *ytemp;
	long i; 

	yerr  = (double*)mxMalloc(neq*sizeof(double));
	ytemp = (double*)mxMalloc(neq*sizeof(double));
	
	for (;;) {
		ODEIntegratorRK5(f, neq, *x, y, dydx, h, ytemp, yerr, varargs);
		errmax = 0.0; for (i = 0; i < neq; i++) errmax = DMAX(errmax, fabs(yerr[i]/yscal[i])); errmax /= eps;
		if (errmax <= 1.0) break;
		htemp = ODE_SAFETY*h*pow(errmax, ODE_PSHRNK);
		h = (h >= 0.0 ? DMAX(htemp, 0.1*h) : DMIN(htemp, 0.1*h));
		xnew = (*x) + h; if (xnew == *x) mexErrMsgTxt("Stepsize underflow in ODEIntegratorRK5.");
	}
	
	if (errmax > ODE_ERRCON) *hnext = ODE_SAFETY*h*pow(errmax, ODE_PGROW); else *hnext = 5.0*h;
	*x += (*hdid = h); for (i = 0; i < neq; i++) y[i] = ytemp[i];
	
	mxFree(ytemp); mxFree(yerr);
}

void ODESolve(void (*f)(double, double*, double*, void*), long neq, double* y0,
    double x1, double x2, double eps, double h1, double hmin, Vector* xout, 
    Vector* yout, void* varargs)
/*Integrates the supplied ODE set f with number of equations neq from value x1 to x2 with
starting values y0 at x1 requested relative accuracy specified by eps. hmin is the minimal
stepsize that can be taken by the integrator to achieve the desired accuracy. h1 is an
estimation of the first stepsize.*/ 
{
  	double *yscal, *y, *dydx;
	double x, h, hdid, hnext;
	long nstp, i;
	
    yscal = (double*)mxMalloc(neq*sizeof(double));
	y     = (double*)mxMalloc(neq*sizeof(double));
	dydx  = (double*)mxMalloc(neq*sizeof(double));
	
	x = x1;	h = SIGN(h1, x2-x1);
	for (i = 0; i < neq; i++) y[i] = y0[i];
	
	for (nstp = 1; nstp <= ODE_MAXSTP; nstp++) 
	{
		(*f)(x, y, dydx, varargs);
        VectorAddScalar(xout, x);
        for (i = 0; i < neq; i++) VectorAddScalar(yout+i, y[i]);
		
		for (i = 0; i < neq; i++) yscal[i] = fabs(y[i]) + fabs(dydx[i]*h) + ODE_TINY;
		if ((x+h-x2)*(x+h-x1) > 0.0) h = x2 - x;
		
        ODEStepper(f, neq, &x, y, dydx, h, &hdid, &hnext, eps, yscal, varargs);
         
		if ((x-x2)*(x2-x1) >= 0.0) {
		    VectorAddScalar(xout, x);
		    for (i = 0; i < neq; i++) VectorAddScalar(yout+i, y[i]);
		    
			mxFree(dydx);
			mxFree(y);
			mxFree(yscal);
			return;
		}
		if (fabs(hnext) <= hmin) mxErrMsgTxt("Step size too small in IntegrateODE.");
		h = hnext;
	}
	mxErrMsgTxt("Too many steps in routine IntegrateODE.");
}

#undef ODE_SAFETY
#undef ODE_PGROW
#undef ODE_PSHRNK
#undef ODE_ERRCON
#undef ODE_MAXSTP
#undef ODE_TINY
#undef DMAX
#undef DMIN
#undef SIGN

/*-------------------------------------------------------------------------------*/
#define ERRMSG_MAXLENGTH    200

double* GetRowVectorField(mxArray *S, char* FieldName, long N)
{
    mxArray* FieldValue; char ErrMsg[ERRMSG_MAXLENGTH+1];
    
    FieldValue = mxGetField(S, 0, FieldName);
    if (FieldValue == NULL)
    {
        sprintf(ErrMsg, "Invalid parameter structure: connat find field '%s'.", FieldName);
        mexErrMsgTxt(ErrMsg);
    }    
    else if (!mxIsNumeric(FieldValue) || (mxGetM(FieldValue) != 1) || (mxGetN(FieldValue) != N))
    {
        sprintf(ErrMsg, "Parameter '%s' must be a numerical row vector of %d elements.", FieldName, N);
        mexErrMsgTxt(ErrMsg);
    }    
    else return mxGetPr(FieldValue);
}

double GetScalarField(mxArray *S, char* FieldName)
{
    mxArray* FieldValue; char ErrMsg[ERRMSG_MAXLENGTH+1];

    FieldValue = mxGetField(S, 0, FieldName);
    if (FieldValue == NULL) 
    {
        sprintf(ErrMsg, "Invalid parameter structure: connat find field '%s'.", FieldName);
        mexErrMsgTxt(ErrMsg);
    }
    else if (!mxIsNumeric(FieldValue) || (mxGetNumberOfElements(FieldValue) != 1))
    {
        sprintf(ErrMsg, "Parameter '%s' must be a numerical scalar.", FieldName);
        mexErrMsgTxt(ErrMsg);
    }    
    else return mxGetScalar(FieldValue);
}

Vector* GetSpkIn(mxArray* Args[], long N)
{
    Vector* SpkIn; long i, j;
    
    SpkIn = (Vector*)mxMalloc(N*sizeof(Vector));
    for (i = 0; i < N; i++)
    {
        if (mxIsEmpty(Args[i])) SpkIn[i] = VectorPtrInit(0, NULL);
        else if (mxIsNumeric(Args[i]) && (mxGetM(Args[i]) == 1)) SpkIn[i] = VectorPtrInit(mxGetN(Args[i]), mxGetPr(Args[i])); 
        else
        {
            for (j = 0; j < i; j++) VectorFree(SpkIn+j); mxFree(SpkIn);
            mexErrMsgTxt("Spiketrains must be given as numerical rowvectors.");
        }
    }
    return SpkIn;
}

#undef ERRMSG_MAXLENGTH

/*-------------------------------------------------------------------------------*/
MdlParam GetMdlParam(mxArray* S)
{
    MdlParam P;
    
    P.Tc = GetScalarField(S, "tc");
    P.Cs = GetScalarField(S, "cs");
    P.Ne = (long)GetScalarField(S, "ne");
    P.Ae = GetRowVectorField(S, "ae", P.Ne);    
    P.De = GetScalarField(S, "de");
    P.Ep = GetScalarField(S, "ep");
    P.Es = GetScalarField(S, "es");
    P.El = GetScalarField(S, "el");
    P.Ee = GetScalarField(S, "ee");
    P.Th = GetScalarField(S, "th");
    P.V0 = GetScalarField(S, "v0");
    P.aw = GetRowVectorField(S, "aw", 2);
    
    return P;
}

double CorrectT(double cf, double T)
{
    return pow(cf, (T-22.0)/10.0);
}

MdlData MdlDataInit(MdlParam P, Vector* SpkIn)
{
    MdlData D;
    double* A;
    Vector SpkTmp = {0, 0, NULL};
    long i, n;
    
    /*Save model parameters*/
    D.De = P.De; D.Cs = P.Cs; D.Ep = P.Ep; D.Es = P.Es; D.El = P.El; D.Ee = P.Ee;
    
    /*Temperature correction factors*/
    D.Tc2 = CorrectT(2, P.Tc); D.Tc2_5 = CorrectT(2.5, P.Tc); D.Tc3 = CorrectT(3, P.Tc); D.Tc10 = CorrectT(10, P.Tc);
    
    /*Concatenating all input spiketrains*/
    for (i = 0; i < P.Ne; i++) VectorConcatenate(&SpkTmp, SpkIn[i]);
    D.Nspk = SpkTmp.n; D.Spks = SpkTmp.data;
    
    /*Creating array with associated amplitudes*/
    A = (double*)mxMalloc(D.Nspk*sizeof(double));
    for (i = n = 0; i < P.Ne; n += SpkIn[i].n, i++)
    { 
        long j;
        for (j = 0; j < SpkIn[i].n; j++) A[n+j] = P.Ae[i];
    }
    
    /*Sorting concatenated spikes and their associated amplitudes*/
    QuickSort(D.Spks, 0, D.Nspk-1, A);
    
    /*Calculating excitatory conductancy for spiketimes*/
    D.Gspk = (double*)mxMalloc(D.Nspk*sizeof(double));
    D.Gspk[0] = A[0]; for (i = 1; i < D.Nspk; i++) D.Gspk[i] = D.Gspk[i-1]*exp((SpkTmp.data[i-1]-SpkTmp.data[i])/P.De)+A[i];
    
    mxFree(A);
    
    return D;
}

void MdlDataFree(MdlData D)
{
    mxFree(D.Spks);
    mxFree(D.Gspk);
}

/*-------------------------------------------------------------------------------*/
#define CHANNEL_H_ALPHA(V, Tc1, Tc2)    (2.4 * Tc1 / (1.0 + exp((V + 68.0)/3.0)) + 0.8 * Tc2 / (1.0 + exp(V + 61.3)))
#define CHANNEL_H_BETA(V, Tc)           (3.6 * Tc / (1.0 + exp(-(V + 21.0)/10.0)))
#define CHANNEL_M_ALPHA(V, Tc)          (0.36 * Tc * (V + 49.0) / (1.0 - exp(-(V + 49.0)/3.0)))
#define CHANNEL_M_BETA(V, Tc)           (-0.4 * Tc * (V + 58.0) / (1.0 - exp((V + 58.0)/20.0)))
#define CHANNEL_N_ALPHA(V, Tc)          (0.0282 * Tc * (V + 9.0) / (1.0 - exp(-(V + 9.0)/12.0)))
#define CHANNEL_N_BETA(V, Tc)           (6.0 * Tc * exp(-(V + 144.0)/30.0) + 6.0 * Tc / (1.0 + exp(V + 62.0)))
#define CHANNEL_W_ALPHA(V, Tc)          (0.107 * Tc / (1.0 + exp(-(V + 33.0)/13.1)))
#define CHANNEL_W_BETA(V, Tc)           (0.01881 * Tc * exp(-(V + 30.0)/30.3))
#define HHODE_NEQ   5
#define HHODE_EPS   1e-4
#define HHODE_MINH  1e-7

void HHODE(double t, double* f, double* dfdt, void* varargs)
{
    double w = f[0], n = f[1], m = f[2], h = f[3], V = f[4];
    MdlData* D = (MdlData*)varargs;
    double Gplt, Gpht, Gs, Gl, Ge; long i;
    
    /*Low-threshold potassium conductance*/
    dfdt[0] = CHANNEL_W_ALPHA(V, D->Tc3) * (1.0 - w) - CHANNEL_W_BETA(V, D->Tc3) * w;
    Gplt = 20.0 * D->Tc2_5 * w;

    /*High-threshold potassium conductance*/
    dfdt[1] = CHANNEL_N_ALPHA(V, D->Tc3) * (1.0 - n) - CHANNEL_N_BETA(V, D->Tc3) * n;
    Gpht = 40 * D->Tc2_5 * n;

    /*Sodium conductance*/
    dfdt[2] = CHANNEL_M_ALPHA(V, D->Tc3) * (1.0 - m) - CHANNEL_M_BETA(V, D->Tc3) * m;
    dfdt[3] = CHANNEL_H_ALPHA(V, D->Tc3, D->Tc10) * (1.0 - h) - CHANNEL_H_BETA(V, D->Tc3) * h;
    Gs = 325 * D->Tc2 * (m*m) * h;

    /*Leakage conductance*/
    Gl = 1.7 * D->Tc2;
    
    /*Excitatory conductance*/
    i = BinSearch(D->Spks, D->Nspk, t);
    if (i != -1) Ge = D->Gspk[i]*exp((D->Spks[i]-t)/D->De); else Ge = 0.0;

    /*membrane potential*/
    dfdt[4] = -(1.0/D->Cs) * (Gplt * (V - D->Ep) + Gpht * (V - D->Ep) + Gs * (V - D->Es) + Gl * (V - D->El) + Ge * (V - D->Ee));
}

Vector V2Spk(double Th, Vector t, Vector Vmem)
{
    Vector V = {0, 0, NULL};
    long i = 0;
    
    while (i < Vmem.n)
    {
        if (Vmem.data[i] >= Th)
        {
            double Vmax = Vmem.data[i], tmax = t.data[i];
            while ((++i < Vmem.n) && (Vmem.data[i] >= Th))
            {
                if (Vmem.data[i] > Vmax) { Vmax = Vmem.data[i]; tmax = t.data[i];}
            }
            if (i != Vmem.n) VectorAddScalar(&V, tmax);
        }
        else i++;
    }
    
    return V;
}

void HHModel(MdlParam P, Vector* SpkIn, Vector* SpkOut, Vector* t, Vector* V)
{
    MdlData D;
    double f0[HHODE_NEQ], aw0, bw0, an0, bn0, am0, bm0, ah0, bh0;
    Vector *y;
    long i;
    
    /*Initialize model and start values*/
    D = MdlDataInit(P, SpkIn);
    aw0 = CHANNEL_W_ALPHA(P.V0, D.Tc3); bw0 = CHANNEL_W_BETA(P.V0, D.Tc3);
    f0[0] = aw0 / (aw0 + bw0);
    an0 = CHANNEL_N_ALPHA(P.V0, D.Tc3); bn0 = CHANNEL_N_BETA(P.V0, D.Tc3);
    f0[1] = an0 / (an0 + bn0);
    am0 = CHANNEL_M_ALPHA(P.V0, D.Tc3); bm0 = CHANNEL_M_BETA(P.V0, D.Tc3);
    f0[2] = am0 / (am0 + bm0);
    ah0 = CHANNEL_H_ALPHA(P.V0, D.Tc3, D.Tc10); bh0 = CHANNEL_H_BETA(P.V0, D.Tc3);
    f0[3] = ah0 / (ah0 + bh0);
    f0[4] = P.V0;
    
    y = (Vector*)mxMalloc(HHODE_NEQ*sizeof(Vector));
    for (i = 0; i < HHODE_NEQ; i++) y[i] = VectorScalarInit(0, 0.0);
    
    /*Solve ODE*/
    ODESolve(HHODE, HHODE_NEQ, f0, P.aw[0], P.aw[1], HHODE_EPS, HHODE_MINH, HHODE_MINH, t, y, &D);
    
    /*Creating output spiketrain and membrane potential vector*/
    *V = VectorPtrInit(y[4].n, y[4].data);
    *SpkOut = V2Spk(P.Th, *t, *V);
    
    /*Free dynamic memory*/
    MdlDataFree(D); for (i = 0; i < HHODE_NEQ; i++) VectorFree(y+i); mxFree(y);
}

#undef CHANNEL_H_ALPHA
#undef CHANNEL_H_BETA
#undef CHANNEL_M_ALPHA
#undef CHANNEL_M_BETA
#undef CHANNEL_N_ALPHA
#undef CHANNEL_N_BETA
#undef CHANNEL_W_ALPHA
#undef CHANNEL_W_BETA
#undef HHODE_NEQ
#undef HHODE_EPS
#undef HHODE_MINH

/*-------------------------------------------------------------------------------*/
