function ArgOut = GenWFPlotKS(varargin)

%GENWFPLOTTF  generate waterfall plot.
%
% WARNING: in this version:
%        * CF is also displayed in the title of the wfplot, to do this you need the
%           m-file getCFList.m (TF 07/09/2005)
%        * whether or not the correlograms are difcors is also displayed in the title of the wfplot
%        * the number of correlations can be smoothed using the property 'smoothing'
%           (smoothing is 0 for no smoothing, and the value N passed on to runav in case you want
%           smoothing. (TF 07/09/2005)
%        * using the property 'spline', an interpolation and resampling is possible, defined by a 
%           'resampling factor', that indicates in how many parts each original bin is divided.
%          Resampling factor is 0 for no spline.
%
%   GENWFPLOT(List, RefRow) generate a waterfall plot based on the structure-
%   array List generated by GENWFLIST. The row that contains the information
%   on the reference fiber is supplied as second argument. The structure-array
%   should have the following fieldnames: 'filename', 'iseqp', 'isubseqp', 
%   'iseqn' and 'isubseqn'. The fieldname that contains the values for the
%   distribution of the correlograms on the left ordinate on the waterfall plot
%   must be specified via the property 'discernfieldname'.
%   Additional fields can be present in the structure-array and can be useful
%   in the calculation of the values for an optional right ordinate. See code-
%   section on the meaning of the property 'rightyexpr' for further information.
%
%   S = GENWFPLOT(List, RefRow) also returns a structure-array containing
%   a summary of the parameters extracted from the correlograms in the 
%   waterfall plot. See relevant code-section for explanation on the meaning
%   of the fieldnames.
%
%   E.g.:
%       List = struct('filename', 'A0454', ...
%           'iseqp', num2cell([141, 142, 139, 140, 141]), ...
%           'isubseqp', num2cell([1, 1, 1, 2, 1]), ...
%           'iseqn', num2cell([141, 142, 139, 140, 141]), ...
%           'isubseqn', num2cell([2, 2, 2, 1, 2]), ... 
%           'spl', num2cell([40, 50, 60, 70, 90]));
%       S = GenWFPlot(List, 3, 'discernfieldname', 'spl', ...
%           'discernfieldlabel', 'Intensity', ...
%           'discernfieldunit', 'dB SPL');
%
%       List = struct('filename', 'A0307', ...
%           'iseqp', num2cell([368, 666, 486, 748]), ...
%           'iseqn', num2cell([368, 666, 486, 748]), ...
%           'isubseqp', num2cell([2 2 1 2]), ...
%           'isubseqn', num2cell([1 1 2 1]), ...
%           'freq', num2cell([2046, 2051, 2133, 1919]));
%       RefRow = 2;
%       GenWFPlot(List, RefRow, 'discernfieldname', 'freq', ...
%           'discernfieldlabel', 'Frequency', 'discernfieldunit', 'Hz', ...
%           'rightyexpr', 'greenwood($freq$)', 'rightylabel', 'Distance', ...
%           'rightyunit', 'mm');
%       GenWFPlot(List, RefRow, 'discernfieldname', 'freq', ...
%           'discernfieldlabel', 'Frequency', 'discernfieldunit', 'Hz', ...
%           'cortype', 'within');
%       GenWFPlot(List, RefRow, 'discernfieldname', 'freq', ...
%           'discernfieldlabel', 'Frequency', 'discernfieldunit', 'Hz', ...
%           'rightyexpr', sprintf('log2($freq$/%f)', List(RefRow).freq), ...
%           'rightylabel', '\DeltaFrequency', 'rightyunit', 'octaves');
%       List(1).reffreq = NaN; [List.reffreq] = deal(List(RefRow).freq);
%       GenWFPlot(List, RefRow, 'discernfieldname', 'freq', ...
%           'discernfieldlabel', 'Frequency', 'discernfieldunit', 'Hz', ...
%           'rightyexpr', 'log2($freq$./$reffreq$)', ...
%           'rightylabel', '\DeltaFrequency', 'rightyunit', 'octaves');
%
%   Optional properties and their values can be given as a comma-separated
%   list. To view list of all possible properties and their default value, 
%   use 'factory' as only input argument. See relevant code-section for an
%   explanation on the meaning of the different properties.
%
%   See also GENWFLIST, EXTRACTPSENTRY or COMPARESCCXCC.

%B. Van de Sande 30-08-2005

%--------------------properties and their default values---------------------
%... List properties ...
%The name of the field in the list that contains the values that are used to
%distribute the correlograms over the left ordinate of the waterfall plot.
DefProps.discernfieldname  = 'discernvalue';
%Description of the field. This is used as the label for the left ordinate.
DefProps.discernfieldlabel = '';
%The unit of these values.
DefProps.discernfieldunit  = '';
%... Calculation properties ...
%The property 'cortype' and 'refautocor' specify how the correlograms need to
%be calculated. If the value for the property 'cortype' is set to 'across'(rows)
%and 'refautocor' is set to 'yes' then correlograms are calculated for each pair
%of rows in the list that contain the reference fiber and also the for pair
%that contains the reference fiber twice. When the property 'refautocor' is set
%to 'no' then the latter pair is not calculated.
%When the property 'cortype' is set to 'within'(rows) then the correlograms are
%calculated for each row in the list and based only on information in that row.
%Depending on the supplied information in a row of the list: if for a given row
%information for locating responses to A+ and A- is provided then the correlograms
%are performed across stimulus (which results in a difcor). Else if only A+ or A-
%responses are specified for a row then the correlograms are performed within 
%stimulus. When calculation is performed across rows, a difcor can only be 
%calculated if for both rows the responses for A+ and A- is specified.
DefProps.cortype           = 'across';     %'across' or 'within' ...
DefProps.refautocor        = 'yes';        %'yes' or 'no' ...
%Analysis window in ms. This must be a vector with an even number of elements.
%Each pair of this vector designates a time-interval included in the calculation.
%By default this is from 0 to stimulus duration ('burstdur').
DefProps.anwin             = 'burstdur';   
%The properties 'corbinwidth' and 'cormaxlag' specify the calculation parameters
%for spiketime correlation. See SPTCORR for more information.
DefProps.corbinwidth       = 0.05;         %in ms ...
DefProps.cormaxlag         = 5;            %in ms ...   
%The ratio between units of left ordinate of the waterfall plot and the normalized
%number of coincidences of the correlograms. This property specifies the scaling
%of the correlograms with respect to the left ordinate of the waterfall plot.
DefProps.normcoratio       = 10;           
%... Plot properties ...
%Generate a plot. Should be 'yes' or 'no' ...
DefProps.plot              = 'yes';

%paragraph added by TF (07/09/2005)
%Smooths the WFplot (the normalized correlation). Value should be 0 for no smoothing, or 
%the value N passed on to runav for smoothing
DefProps.smoothing         = 0;

%paragraph added by TF (09/09/2005)
%Splines and resamples the WFplot (the normalized correlation). Value should be 0 for no spline, or 
%the 'resampling factor' (e.g., if the resampling factor is 2, each bin will be split in half). This
%factor has to be a positive integer.
DefProps.spline         = 0;

%Range and stepsize for the abcissa of the waterfall plot.
DefProps.corxrange         = [-5, +5];     %in ms ...
DefProps.corxstep          = 1;            %in ms ...
%If the property 'plotfysitd' is set to 'yes' then the fysiological perceptible 
%ITD range specified in the property 'fysitdrange' is displayed as a yellow
%rectangle on the waterfall plot. If the value is set to 'inv' then this range
%is left white, but the outer ranges are displayed with yellow ractangles.
DefProps.plotfysitd        = 'yes';        %'yes', 'no' or 'inv'(erted) ...
DefProps.fysitdrange       = [-0.4, +0.4]; %in ms ...
%Properties 'plotprimpeaks', 'plotsecpeaks' and 'plotunitbox' add additional
%features to the waterfall plot: primary or secondary peaks for each correlogram
%and a unit box that shows the scaling of the correlograms with respect to the
%left ordinate of the waterfall plot.
DefProps.plotprimpeaks     = 'yes';        %'yes' or 'no' ...
DefProps.plotsecpeaks      = 'yes';        %'yes' or 'no' ...
DefProps.plotunitbox       = 'yes';        %'yes' or 'no' ...
%An additional right ordinate can be added to the waterfall plot. The properties
%'rightylabel' and 'rightyunit' specify the label for this ordinate and the unit
%of its values. The value assigned to each correlogram for this new ordinate is
%decided based on an expression supplied as the value of the property 'rightyexpr'.
%Any MATLAB expression that returns a scalar is valid. These expressions can refer
%to fieldnames in the supplied structure-array. References to fieldnames must be
%enclosed between dollar signs and for branched structures these fieldnames can
%be given using the dot as a fieldname separator. A reference to a fieldname in 
%the expression is substituted by the value of the field at the row for which the
%ordinate value is calculated.
DefProps.rightylabel       = '';
DefProps.rightyunit        = '';
DefProps.rightyexpr        = '';

%--------------------template for row of returned structure-array------------
%For every correlogram calculated in the waterfall plot an element in the 
%structure-array will be present.

%... identification ...
Template.ds1.filename      = '';         %Datafile name for dataset of first
                                         %input in calculation of correlogram,
                                         %i.e. the reference fiber.
Template.ds1.iseqp         = NaN;        %Sequence number of first input's 
                                         %response to the positive noise token.
Template.ds1.seqidp        = '';         %Sequence identifier of first input's
                                         %response to the positive noise token.
Template.ds1.isubseqp      = NaN;        %Subsequence number of first input's 
                                         %response to the positive noise token.
Template.ds1.iseqn         = NaN;        %Sequence number of first input's 
                                         %response to the negative noise token.
Template.ds1.seqidn        = '';         %Sequence identifier of first input's
                                         %response to the negative noise token.
Template.ds1.isubseqn      = NaN;        %Subsequence number of first input's 
                                         %response to the negative noise token.
Template.ds1.discernvalue  = NaN;        %Value of the fieldname used to discern
                                         %this second input from the other 
                                         %elements in the waterfall plot for this
                                         %first input.
Template.ds2.filename      = '';         %Datafile name for dataset of second
                                         %input in calculation of correlogram,
                                         %i.e. the fiber to which the reference
                                         %fiber is compared in the correlogram.
Template.ds2.iseqp         = NaN;        %Sequence number of second input's 
                                         %response to the positive noise token.
Template.ds2.seqidp        = '';         %Sequence identifier of second input's
                                         %response to the positive noise token.
Template.ds2.isubseqp      = NaN;        %Subsequence number of second input's 
                                         %response to the positive noise token.
Template.ds2.iseqn         = NaN;        %Sequence number of second input's 
                                         %response to the negative noise token.
Template.ds2.seqidn        = '';         %Sequence identifier of second input's
                                         %response to the negative noise token.
Template.ds2.isubseqn      = NaN;        %Subsequence number of second input's 
                                         %response to the negative noise token.
Template.ds2.discernvalue  = NaN;        %Value of the fieldname used to discern
                                         %this second input from the other 
                                         %elements in the waterfall plot for this
                                         %second input.
%... parameters extracted from correlograms ...
Template.magnatzero        = NaN;        %Magnitude at zero microseconds 
                                         %delay in number of coincidences.
Template.magnatzeronorm    = NaN;        %Normalized magnitude at zero delay
                                         %(DriesNorm)
Template.primpeak.delay    = NaN;        %Delay in microseconds for primary
                                         %peak, i.e. the best delay.
Template.primpeak.magn     = NaN;        %Magnitude of primary peak in number
                                         %of coincidences.
Template.primpeak.normmagn = NaN;        %Normalized magnitude of primary peak.
Template.secpeaks.delay    = [NaN, NaN]; %Delay in microseconds for secondary
                                         %peaks. This is a two-element vector,
                                         %the first element containing the 
                                         %parameter for the left secondary 
                                         %peak and the second element the 
                                         %parameter for the right peak.
Template.secpeaks.magn     = [NaN, NaN]; %Magnitude of secondary peaks in 
                                         %number of coincidences. This is 
                                         %returned as a two-element vector.
Template.secpeaks.normmagn = [NaN, NaN]; %Normalized magnitude of secondary
                                         %peaks. This is returned as a two-
                                         %element vector.                                        
                                         
                                         
%--------------------------------main program--------------------------------
%Evaluate input arguments ...
if (nargin == 1) & ischar(varargin{1}) & strcmpi(varargin{1}, 'factory')
    disp('Properties and their factory defaults:'); 
    disp(DefProps);
    return;
else
    [List, RefRow, Props] = ParseArgs(DefProps, varargin{:}); 
end

%Calculate auto- or crosscorrelograms ...
[CorFncs, RefRow] = List2CorFncs(List, RefRow, Props);

%Display crosscorrelograms if requested...
if strcmpi(Props.plot, 'yes')
    DisplayCorFncs(CorFncs, RefRow, Props); 
end

%Return structure-array with extracted parameters if requested ...
if (nargout == 1), ArgOut = structtemplate(CorFncs, Template, 'reduction', 'on');
elseif (nargout > 1), error('Wrong number of output arguments.'); end

%add field lag and normco to ArgOut (added by TF, 12/09/2005)
ArgOut(1).lag = NaN;
ArgOut(1).normco = NaN;
for i=1:numel(CorFncs)
    ArgOut(i).lag = CorFncs(i).lag;
    ArgOut(i).normco = CorFncs(i).normco;
end

%-------------------------------local functions------------------------------
function [List, RefRow, Props] = ParseArgs(DefProps, varargin)

%Checking mandatory arguments ...
if (nargin < 2), error('Wrong number of arguments.'); end
if ~isstruct(varargin{1}) | isempty(varargin{1}), 
    error('First argument should be non-empty structure-array.'); 
end
%Checking of structure-array is postponed until properties and their values are
%checked ...
List = varargin{1}(:); NElem = length(List); 
if ~isnumeric(varargin{2}) | (length(varargin{2}) ~= 1),
    error('Second argument should be positive integer.');
end
RefRow = varargin{2};
if ~ismember(RefRow, 1:NElem), error('Reference row does not exist.'); end

%Check properties ...
Props = CheckPropList(DefProps, varargin{3:end});
Props = CheckAndTransformProps(Props);

%Transforming the supplied structure-array ...
[List, RefRow] = CheckAndTransformList(List, Props, RefRow);

%----------------------------------------------------------------------------
function [List, RefRow] = CheckAndTransformList(List, Props, RefRow)

%Decompose structure-array ...
try, [Data, FNames] = destruct(List);
catch, error('Supplied structure-array is invalid.'); end
N = length(List);

%Check and transform decomposed structure-array ...
if ~all(ismember({'filename', 'iseqp', 'isubseqp', 'iseqn', 'isubseqn'}, ...
        FNames)), 
    error(['Given structure-array must have fieldnames ''filename'', ''iseqp'', ', ...
            '''isubseqp'', ''iseqn'' and ''isubseqn''.']);
end
if ~ismember(Props.discernfieldname, FNames),
    error(sprintf(['The field with name ''%s'' doesn''t exist in the ', ...
        'supplied structure-array.'], Props.discernfieldname)); 
end
FileNames = Data(:, find(ismember(FNames, 'filename')));
if ~all(cellfun('isclass', FileNames, 'char')),
    error(['The field with name ''filename'' in the supplied structure-array must ', ...
            'contain entries of class character string.']);
end    
if any(cellfun('isempty', FileNames)),
    error(['The field with name ''filename'' in the supplied structure-array cannot ', ...
            'contain empty entries.']);
end
iSeqP = Data(:, find(ismember(FNames, 'iseqp')));
if ~all(cellfun('isclass', iSeqP, 'double')) | ~all(cellfun('prodofsize', iSeqP) == 1),
    error(['The field with name ''iseqp'' in the supplied structure-array can only ', ...
            'contain scalar doubles.']);
else, iSeqP = cat(1, iSeqP{:}); end
iSubSeqP = Data(:, find(ismember(FNames, 'isubseqp')));
if ~all(cellfun('isclass', iSubSeqP, 'double')) | ~all(cellfun('prodofsize', iSubSeqP) == 1),
    error(['The field with name ''isubseqp'' in the supplied structure-array can only ', ...
            'contain scalar doubles.']);
else, iSubSeqP = cat(1, iSubSeqP{:}); end
iSeqN = Data(:, find(ismember(FNames, 'iseqn')));
if ~all(cellfun('isclass', iSeqN, 'double')) | ~all(cellfun('prodofsize', iSeqN) == 1),
    error(['The field with name ''iseqn'' in the supplied structure-array can only ', ...
            'contain scalar doubles.']);
else, iSeqN = cat(1, iSeqN{:}); end
iSubSeqN = Data(:, find(ismember(FNames, 'isubseqn')));
if ~all(cellfun('isclass', iSubSeqN, 'double')) | ~all(cellfun('prodofsize', iSubSeqN) == 1),
    error(['The field with name ''isubseqn'' in the supplied structure-array can only ', ...
            'contain scalar doubles.']);
else, iSubSeqN = cat(1, iSubSeqN{:}); end
DiscernValues = Data(:, find(ismember(FNames, Props.discernfieldname)));
if ~all(cellfun('isclass', DiscernValues, 'double')) | ...
        ~all(cellfun('prodofsize', DiscernValues) == 1),
    error(sprintf(['The field with name ''%s'' in the supplied structure-array can only ', ...
            'contain scalar doubles.'], Props.discernfieldnames));
else, DiscernValues = cat(1, DiscernValues{:}); end

%If a row has a NaN for the field 'iseqp' then the field 'isubseqp' is also
%set to NaN and vice versa. This is also applicable to the fields 'iseqn' and
%'isubseqn' ...
idxNaN = find(isnan(iSeqP) | isnan(iSubSeqP));
[iSeqP(idxNaN), iSubSeqP(idxNaN)] = deal(NaN);
idxNaN = find(isnan(iSeqN) | isnan(iSubSeqN));
[iSeqN(idxNaN), iSubSeqN(idxNaN)] = deal(NaN);
%A row in the list must specify information on responses to a positive noise
%token, a negative noise token or both. If a row specifies no information at
%all the supplied structure-array is invalid ...
if any(isnan(iSeqP) & isnan(iSeqN)),
    error(['The supplied structure-array contains an entry that neither specifies ',...
            'responses to A+, nor to A-.']);
end
%The values of the discerning field cannot be NaN ...
if any(isnan(DiscernValues)),
    error(['The field with name ''%s'' in the supplied structure-array cannot ', ...
            'contain NaN''s.'], Props.discernfieldname);
end

%Add extra column to structure-array with values for right ordinate ...
if ~isempty(Props.rightyexpr)
    try 
        Expr = ParseExpr(Props.rightyexpr, FNames);
    catch
        error('Property ''rightyexpr'' must be a valid expression.'); 
    end
    RightYValues = EvalExpr(Expr, Data);
else
    RightYValues = repmat(NaN, N, 1); 
end

%Reassemble structure-array ...
CheckedFNames = {'filename', 'iseqp', 'isubseqp', 'iseqn', 'isubseqn', ...
        Props.discernfieldname, 'rightyvalue'};
idxRemCols = find(~ismember(FNames, CheckedFNames));
List = construct([FileNames, num2cell([iSeqP, iSubSeqP, iSeqN, iSubSeqN, ...
            DiscernValues, RightYValues]), Data(:, idxRemCols)], ...
            [CheckedFNames, FNames(idxRemCols)]);

%Sort the supplied structure-array according to the values of the discerning
%field in descending order ...

%Kevin:Create an extended list containing a boolean value "RefRow", so we
%can know what RefRow is after sorting.
ListExt = List;
for i=1:(RefRow-1)
    ListExt(i).RefRow = 0;
end
ListExt(RefRow).RefRow = 1;
for i=(RefRow+1):length(List)
    ListExt(i).RefRow = 0;
end

ListExt = structsort(ListExt, Props.discernfieldname, 'mode', 'desc');
RefRow = find([ListExt.RefRow]);

List = structreduce(ListExt, fieldnames(List));

%----------------------------------------------------------------------------
function Props = CheckAndTransformProps(Props)

%List properties ...
if ~ischar(Props.discernfieldname) | (size(Props.discernfieldname, 1) ~= 1), 
    error('Property ''discernfieldname'' must be a non-empty character string.'); 
end
if ~ischar(Props.discernfieldlabel) | ~(isempty(Props.discernfieldlabel) | ...
        (size(Props.discernfieldlabel, 1) == 1)), 
    error('Property ''discernfieldlabel'' must be a character string.'); 
end
if ~ischar(Props.discernfieldunit) | ~(isempty(Props.discernfieldunit) | ...
        (size(Props.discernfieldunit, 1) == 1)), 
    error('Property ''discernfieldunit'' must be a character string.'); 
end

%Calculation properties ...
if ~any(strcmpi(Props.cortype, {'across', 'within'})), 
    error('Property ''cortype'' must be ''across'' or ''within''.'); 
end
if ~any(strcmpi(Props.refautocor, {'yes', 'no'})), 
    error('Property ''refautocor'' must be ''yes'' or ''no''.'); 
end
if ~(ischar(Props.anwin) & any(strcmpi(Props.anwin, {'burstdur', 'stimdur'}))) & ... 
        ~(ischar(Props.anwin) & strcmpi(Props.anwin, 'nostim')) & ... 
        ~(ischar(Props.anwin) & strcmpi(Props.anwin, 'repdur')) & ...
        ~(isnumeric(Props.anwin) & any(size(Props.anwin) == 1) & ...
        mod(length(Props.anwin), 2) & all(Props.anwin >= 0) & ...
        isequal(Props.anwin, unique(Props.anwin))), 
    error('Invalid value for property ''anwin''.');
end
if ~isnumeric(Props.corbinwidth) | (length(Props.corbinwidth) ~= 1) | ...
        (Props.corbinwidth <= 0), 
    error('Invalid value for property ''corbinwidth''.'); 
end
if ~isnumeric(Props.cormaxlag) | (length(Props.cormaxlag) ~= 1) | ...
        (Props.cormaxlag <= 0), 
    error('Invalid value for property ''cormaxlag''.'); 
end
if ~isnumeric(Props.normcoratio) | (length(Props.normcoratio) ~= 1) | ...
        (Props.normcoratio <= 0), 
    error('Invalid value for property ''normcoratio''.'); 
end

%Plot properties ...
if ~any(strcmpi(Props.plot, {'yes', 'no'})), 
    error('Property ''plot'' must be ''yes'' or ''no''.'); 
end
if ~isinrange(Props.corxrange, [-Inf +Inf]), 
    error('Invalid value for property ''corxrange''.'); 
end
if ~isnumeric(Props.corxstep) | (length(Props.corxstep) ~= 1) | ...
        (Props.corxstep <= 0), 
    error('Invalid value for property ''corxstep''.'); 
end
if ~any(strcmpi(Props.plotfysitd, {'yes', 'no', 'inv'})), 
    error('Property ''plotfysitd'' must be ''yes'', ''inv'' or ''no''.'); 
end
if ~isinrange(Props.fysitdrange, [-Inf, +Inf]), 
    error('Property ''fysitdrange'' must be a two-element numeric vector.'); 
end
if ~any(strcmpi(Props.plotprimpeaks, {'yes', 'no'})), 
    error('Property ''plotprimpeaks'' must be ''yes'' or ''no''.'); 
end
if ~any(strcmpi(Props.plotsecpeaks, {'yes', 'no'})), 
    error('Property ''plotsecpeaks'' must be ''yes'' or ''no''.'); 
end
if ~any(strcmpi(Props.plotunitbox, {'yes', 'no'})), 
    error('Property ''plotunitbox'' must be ''yes'' or ''no''.'); 
end
if ~ischar(Props.rightylabel) | ~(isempty(Props.rightylabel) | ...
        (size(Props.discernfieldlabel, 1) == 1)), 
    error('Property ''rightylabel'' must be a character string.'); 
end
if ~ischar(Props.rightyunit) | ~(isempty(Props.rightyunit) | ...
        (size(Props.rightyunit, 1) == 1)), 
    error('Property ''rightyunit'' must be a character string.'); 
end
if ~ischar(Props.rightyexpr) | ~(isempty(Props.rightyexpr) | ...
        (size(Props.rightyexpr, 1) == 1)), 
    error('Property ''rightyexpr'' must be a valid expression.');
end

%added by TF (07/09/2005):
if ~isnumeric(Props.smoothing), 
    error('Property ''smoothing'' must be numeric'); 
end

%added by TF (09/09/2005):
if ~isnumeric(Props.spline), 
    error('Property ''spline'' must be numeric'); 
end

%----------------------------------------------------------------------------
function [CorFncs, RefRow] = List2CorFncs(List, RefRow, Props)

%Calculate lags ...
[dummy, Lag] = SPTCORR([], [], Props.cormaxlag, Props.corbinwidth);
%Pre-allocation ...
N = length(List); 
[NrOfCo, NormCo] = deal(zeros(N, length(Lag))); CorType = repmat({''}, N, 1);
%Decompose the information in the supplied structure-array ...
[IdData, IdFNames, UsrData, UsrFNames] = DecomposeList(List, Props);
%Collect additional identification information ...
[IdData, IdFNames] = AssembleSeqIds(IdData, IdFNames);

%Calculate correlograms across or within rows of the supplied 
%structure-array ...
if strcmpi(Props.cortype, 'across'),
    %Load reference cell ...
    [Spt1p, Spt1n, WinDur1] = LoadSpkTr(List(RefRow), Props.anwin);
    
    %Calculation of crosscorrelograms ...
    for n = setdiff(1:N, RefRow),
        %Load compare cell ...
        [Spt2p, Spt2n, WinDur2] = LoadSpkTr(List(n), Props.anwin);
        %Calculate correlogram ...
        [NrOfCo(n, :), NormCo(n, :), CorType{n}] = CalcCorFnc(Spt1p, Spt1n, ...
            WinDur1, Spt2p, Spt2n, WinDur2, Props);
    end

    %Calculation of autocorrelogram of reference fiber if requested ...
    if strcmpi(Props.refautocor, 'yes'),
        %Assemble correlation information ...
        CorIdData = [repmat(IdData(RefRow, :), N, 1), IdData]; 
        
        [NrOfCo(RefRow, :), NormCo(RefRow, :), CorType{RefRow}] = ... %in this line, CorType{n} was changed in CorType{RefRow} by TF, on 08/09/2005, to fix a problem with the staggering of the reference SAC if there is only data for one interaural correlation 
            CalcCorFnc(Spt1p, Spt1n, WinDur1, Props);
    else,
        %Assemble correlation information ...
        CorIdData = [repmat(IdData(RefRow, :), N-1, 1), ...
                IdData(setdiff(1:N, RefRow), :)]; 

        NrOfCo(RefRow, :) = []; NormCo(RefRow, :) = []; CorType(RefRow) = []; 
        if ~isempty(UsrData), UsrData(RefRow) = []; end
        RefRow = NaN; N = N - 1;
    end
else,
    for n = 1:N,
        %Load spiketimes ...
        [SptP, SptN, WinDur] = LoadSpkTr(List(n), Props.anwin);
        %Calculate correlogram ...
        [NrOfCo(n, :), NormCo(n, :), CorType{n}] = CalcCorFnc(SptP, SptN, ...
            WinDur, Props);
    end
    
    %Assemble correlation information ...
    CorIdData = repmat(IdData, 1, 2); RefRow = NaN;
end

%added by TF, 07/09/2005, smooth if asked for smoothing
if Props.smoothing~=0, NrOfCo = smoothCor(NrOfCo, Props.smoothing); NormCo = smoothCor(NormCo, Props.smoothing); end



%added by TF, 09/09/2005, spline if asked for spline
if Props.spline~=0, [Lag, NrOfCo, NormCo] = splineCor(Lag, NrOfCo, NormCo, Props.spline); end

%Extract main and secundary peaks from correlograms ...
[Max, MaxNorm, LagAtMax] = deal(zeros(N, 3)); 
[MagnAtZero, MagnAtZeroNorm] = deal(zeros(N, 1)); idxZero = find(abs(Lag-0)<=4e-014);
for n = 1:N,
    [MagnAtZero(n), MagnAtZeroNorm(n)] = deal(NrOfCo(n, idxZero), NormCo(n, idxZero));
    [LagAtMax(n, 2), Max(n, 2), LagAtMax(n, [1 3]), Max(n, [1 3])] = GetPeaks(Lag, NrOfCo(n, :));
    [dummy, MaxNorm(n, 2), dummy, MaxNorm(n, [1 3])] = GetPeaks(Lag, NormCo(n, :)); 
end

%Assembly of structure-array ...
NFields = length(IdFNames);
CorIdFNames = [ cellstr([repmat('ds1.', NFields, 1), char(IdFNames)]); ...
        cellstr([repmat('ds2.', NFields, 1), char(IdFNames)])]';
FNames = [ CorIdFNames, {'lag', 'nrofco', 'normco', 'cortype', 'magnatzero', ...
        'magnatzeronorm', 'primpeak.delay', 'primpeak.magn', 'primpeak.normmagn', ...
        'secpeaks.delay', 'secpeaks.magn', 'secpeaks.normmagn'}, UsrFNames];
Data = [ CorIdData, repmat({Lag}, N, 1), num2cell(NrOfCo, 2), num2cell(NormCo, 2), ...
        CorType, num2cell(MagnAtZero), num2cell(MagnAtZeroNorm), ...
        num2cell(LagAtMax(:, 2)), num2cell(Max(:, 2)), num2cell(MaxNorm(:, 2)), ...
        num2cell(LagAtMax(:, [1, 3]), 2), num2cell(Max(:, [1, 3]), 2), ...
        num2cell(MaxNorm(:, [1, 3]), 2), UsrData];
CorFncs = construct(Data, FNames);

%----------------------------------------------------------------------------
function [IdData, IdFNames, UsrData, UsrFNames] = DecomposeList(List, Props)

[Data, FNames] = destruct(List);

IdFNames = {'filename', 'iseqp', 'isubseqp', 'iseqn', 'isubseqn', ...
        Props.discernfieldname, 'rightyvalue'};
N = length(IdFNames); permIdx = zeros(1, N);
for n = 1:N, permIdx(n) = find(ismember(FNames, IdFNames{n})); end
IdData = Data(:, permIdx);
IdFNames(find(strcmp(IdFNames, Props.discernfieldname))) = {'discernvalue'};

UsrFNames = setdiff(FNames, IdFNames); N = length(UsrFNames); 
if (N > 0),
    permIdx = zeros(1, N);
    for n = 1:N, permIdx(n) = find(ismember(FNames, UsrFNames{n})); end
    UsrData = Data(:, permIdx);
    UsrFNames = cellstr([repmat('usr.', N, 1), char(UsrFNames)])';
else, [UsrData, UsrFNames] = deal({}); end

%----------------------------------------------------------------------------
function [IdData, IdFNames] = AssembleSeqIds(IdData, IdFNames)

%Reorganize data ...
FileNames = IdData(:, find(ismember(IdFNames, 'filename')));
Seqp = cat(1, IdData{:, find(ismember(IdFNames, 'iseqp'))});
SubSeqp = cat(1, IdData{:, find(ismember(IdFNames, 'isubseqp'))});
Seqn = cat(1, IdData{:, find(ismember(IdFNames, 'iseqn'))});
SubSeqn = cat(1, IdData{:, find(ismember(IdFNames, 'isubseqn'))});

N = size(IdData, 1);
%Preallocation ...
[SeqIDp, SeqIDn] = deal(repmat({''}, N, 1));
[SubSeqValp, SubSeqValn] = deal(zeros(N, 1));
[SubSeqUnitp, SubSeqUnitn] = deal(repmat({''}, N, 1));
for n = 1:N,
    [SeqIDp{n}, SubSeqValp(n), SubSeqUnitp{n}] = ExtractInfoFromDs( ...
        FileNames{n}, Seqp(n), SubSeqp(n));
    [SeqIDn{n}, SubSeqValn(n), SubSeqUnitn{n}] = ExtractInfoFromDs( ...
        FileNames{n}, Seqn(n), SubSeqn(n));
end

%Add extra columns ...
[IdData, IdFNames] = AddColumns(IdData, IdFNames, 'iseqp', SeqIDp, 'seqidp');
[IdData, IdFNames] = AddColumns(IdData, IdFNames, 'isubseqp', num2cell(SubSeqValp), ...
    'subseqvalp', SubSeqUnitp, 'subsequnitp');
[IdData, IdFNames] = AddColumns(IdData, IdFNames, 'iseqn', SeqIDn, 'seqidn');
[IdData, IdFNames] = AddColumns(IdData, IdFNames, 'isubseqn', num2cell(SubSeqValn), ...
    'subseqvaln', SubSeqUnitn, 'subsequnitn');

%----------------------------------------------------------------------------
function [SeqID, SubSeqVal, SubSeqUnit] = ExtractInfoFromDs(FileName, iSeq, iSubSeq)

if ~isnan(iSeq) & ~isnan(iSubSeq),
    try, ds = dataset(FileName, iSeq);
    catch, error(sprintf('Could not load dataset %s #%d.', FileName, iSeq)); end
    if (ds.nrec < iSubSeq), 
        error(sprintf('Subsequence %d wasn''t recorded or doesn''t exist for dataset %s #%d', ...
            iSubSeq, FileName, iSeq)); 
    end
    [SeqID, SubSeqVal, SubSeqUnit] = deal(ds.seqid, ds.indepval(iSubSeq), ds.indepunit);
else, [SeqID, SubSeqVal, SubSeqUnit] = deal('', NaN, ''); end 

%----------------------------------------------------------------------------
function [Data, FNames] = AddColumns(Data, FNames, AfterFName, varargin)

Ncols = length(varargin)/2;
afterIdx = find(ismember(FNames, AfterFName));
FNames(afterIdx:end+Ncols) = [FNames(afterIdx), varargin(2:2:end), FNames(afterIdx+1:end)];
Data(:, afterIdx:end+Ncols) = [Data(:, afterIdx), varargin{1:2:end}, Data(:, afterIdx+1:end)];

%----------------------------------------------------------------------------
function [SptP, SptN, WinDur] = LoadSpkTr(ListEntry, AnWin)

if ~isnan(ListEntry.iseqp) & ~isnan(ListEntry.isubseqp),
    try, dsP = dataset(ListEntry.filename, ListEntry.iseqp); 
    catch, 
        error(sprintf('Could not load dataset %s #%d.', ListEntry.filename, ...
            ListEntry.iseqp)); 
    end    
    AnWinP = ExpandAnWin(dsP, AnWin);
    SptP   = anwin(dsP.spt(ListEntry.isubseqp, :), AnWinP);

    %Duration of analysis window in ms ...
    WinDur(1) = GetAnWinDur(AnWinP);
else, 
    dsP = dataset; 
    [AnWinP, WinDur(1)] = deal(NaN); 
    SptP = {};
end

if ~isnan(ListEntry.iseqn) & ~isnan(ListEntry.isubseqn),
    try, dsN = dataset(ListEntry.filename, ListEntry.iseqn); 
    catch,
        error(sprintf('Could not load dataset %s #%d.', ListEntry.filename, ...
            ListEntry.iseqn)); 
    end   
    AnWinN = ExpandAnWin(dsN, AnWin);
    SptN   = anwin(dsN.spt(ListEntry.isubseqn, :), AnWinN);

    %Duration of analysis window in ms ...
    WinDur(2) = GetAnWinDur(AnWinN);
else,
    dsN = dataset; 
    [AnWinN, WinDur(2)] = deal(NaN); 
    SptN = {};
end

%----------------------------------------------------------------------------
function [CorFnc, NormCorFnc, CorType] = CalcCorFnc(varargin)

%Check input arguments ...
if (nargin == 7),
    %CALCCORFNC(Spt1p, Spt1n, WinDur1, Spt2p, Spt2n, WinDur2, Props)
    [Spt1p, Spt1n, WinDur1, Spt2p, Spt2n, WinDur2, Props] = deal(varargin{:});

    if ~isempty(Spt1p) & ~isempty(Spt2p),
        Ypp = SPTCORR(Spt1p, Spt2p, Props.cormaxlag, Props.corbinwidth); %SCC ...
        YppNorm = ApplyNorm(Ypp, computeDriesNorm(Spt1p, WinDur1(1), Spt2p, ...
            WinDur2(1), Props.corbinwidth));
    end
        
    if ~isempty(Spt1n) & ~isempty(Spt2n),
        Ynn = SPTCORR(Spt1n, Spt2n, Props.cormaxlag, Props.corbinwidth); %SCC ...
        YnnNorm = ApplyNorm(Ynn, computeDriesNorm(Spt1n, WinDur1(2), Spt2n, ...
            WinDur2(2), Props.corbinwidth));
    end
    
    if ~isempty(Spt1p) & ~isempty(Spt2n),
        Ypn = SPTCORR(Spt1p, Spt2n, Props.cormaxlag, Props.corbinwidth); %XCC ...
        YpnNorm = ApplyNorm(Ypn, computeDriesNorm(Spt1p, WinDur1(1), Spt2n, ...
            WinDur2(2), Props.corbinwidth));
    end
    
    if ~isempty(Spt1n) & ~isempty(Spt2p),
        Ynp = SPTCORR(Spt1n, Spt2p, Props.cormaxlag, Props.corbinwidth); %XCC ...
        YnpNorm = ApplyNorm(Ynp, computeDriesNorm(Spt1n, WinDur1(2), Spt2p, ...
            WinDur2(1), Props.corbinwidth));
    end
    
    if exist('Ypp', 'var') & exist('Ynn', 'var'), 
        Yscc = mean([Ypp; Ynn]); YsccNorm = mean([YppNorm; YnnNorm]);
    elseif exist('Ypp', 'var'), Yscc = Ypp; YsccNorm = YppNorm;
    elseif exist('Ynn', 'var'), Yscc = Ynn; YsccNorm = YnnNorm; end
    
    if exist('Ypn', 'var') & exist('Ynp', 'var'), 
        Yxcc = mean([Ypn; Ynp]); YxccNorm = mean([YpnNorm; YnpNorm]);
    elseif exist('Ypn', 'var'), Yxcc = Ypn; YxccNorm = YpnNorm;
    elseif exist('Ynp', 'var'), Yxcc = Ynp; YxccNorm = YnpNorm; end

    if exist('Yscc', 'var') & exist('Yxcc', 'var'),
        CorFnc = Yscc-Yxcc; NormCorFnc = YsccNorm-YxccNorm;
        CorType = 'dif';
    elseif exist('Yscc', 'var'),
        CorFnc = Yscc; NormCorFnc = YsccNorm;
        CorType = 'cor';
    else,
        CorFnc = Yxcc; NormCorFnc = YxccNorm;
        CorType = 'cor';
    end
else, 
    %CALCCORFNC(SptP, SptN, WinDur, Props)
    [SptP, SptN, WinDur, Props] = deal(varargin{:});
    
    if ~isempty(SptP) & ~isempty(SptN),
        Ypp = SPTCORR(SptP, 'nodiag', Props.cormaxlag, Props.corbinwidth); %SAC ...
        YppNorm = ApplyNorm(Ypp, computeDriesNorm(SptP, WinDur(1), Props.corbinwidth));
        
        Ynn = SPTCORR(SptN, 'nodiag', Props.cormaxlag, Props.corbinwidth); %SAC ...
        YnnNorm = ApplyNorm(Ynn, computeDriesNorm(SptN, WinDur(2), Props.corbinwidth));
        
        Ypn = SPTCORR(SptP, SptN, Props.cormaxlag, Props.corbinwidth); %XAC ...
        YpnNorm = ApplyNorm(Ypn, computeDriesNorm(SptP, WinDur(1), ...
            SptN, WinDur(2), Props.corbinwidth));
        
        %Ynp = SPTCORR(SptN, SptP, Props.cormaxlag, Props.corbinwidth); %XAC ...
        %YnpNorm = ApplyNorm(Ynp, computeDriesNorm(SptN, WinDur(2), ...
        %    SptP, WinDur(1), Props.corbinwidth));
        Ynp = Ypn; YnpNorm = YpnNorm;
        
        Ysac = mean([Ypp; Ynn]); Yxac = mean([Ypn; Ynp]);
        CorFnc = Ysac - Yxac;
        YsacNorm = mean([YppNorm; YnnNorm]); YxacNorm = mean([YpnNorm; YnpNorm]);
        NormCorFnc = YsacNorm - YxacNorm;
        CorType = 'dif';
        
    elseif ~isempty(SptP),
        CorFnc = SPTCORR(SptP, 'nodiag', Props.cormaxlag, Props.corbinwidth); %SAC ...
        NormCorFnc = ApplyNorm(CorFnc, computeDriesNorm(SptP, WinDur(1), Props.corbinwidth));
        CorType = 'cor';
        
    elseif ~isempty(SptN),
        CorFnc = SPTCORR(SptN, 'nodiag', Props.cormaxlag, Props.corbinwidth); %SAC ...
        NormCorFnc = ApplyNorm(CorFnc, computeDriesNorm(SptN, WinDur(2), Props.corbinwidth));
        CorType = 'cor';
        
    end    
end

%----------------------------------------------------------------------------
function DriesNorm = computeDriesNorm(varargin)

if (nargin == 5),
    %COMPUTEDRIESNORM(Spt1, WinDur1, Spt2, WinDur2, CorBinWidth)
    [Spt1, WinDur1, Spt2, WinDur2, CorBinWidth] = deal(varargin{:});

    NRep1 = length(Spt1); NRep2 = length(Spt2);
    NSpikes1 = sum(cellfun('length', Spt1)); NSpikes2 = sum(cellfun('length', Spt2));
    
    %Add innocent 1e-10 to number of spikes to prevent divide by zero 
    %warning ...
    Rate1 = (1e-10+NSpikes1)/WinDur1/NRep1; Rate2 = (1e-10+NSpikes2)/WinDur2/NRep2;
    
    if (NRep2 == 0), NF = WinDur1*(NRep1*(NRep1-1)); Rate2 = Rate1;
    elseif (NRep1 == 0), NF = WinDur2*(NRep2*(NRep2-1)); Rate1 = Rate2;
    elseif isequal(WinDur1, WinDur2), NF = WinDur1*NRep1*NRep2;
    else,
        warning('Using average window duration in calculation of normalization coefficient.');
        NF = mean([WinDur1, WinDur2])*NRep1*NRep2;
    end
    DriesNorm = NF*Rate1*Rate2*CorBinWidth;
else,
    %COMPUTEDRIESNORM(Spt, WinDur, CorBinWidth)
    [Spt, WinDur, CorBinWidth] = deal(varargin{:});

    NRep = length(Spt); NSpikes = sum(cellfun('length', Spt));
    %Add innocent 1e-10 to number of spikes to prevent divide by zero 
    %warning ...
    Rate = (1e-10+NSpikes)/WinDur/NRep; 
    NF = WinDur*(NRep*(NRep-1));
    DriesNorm = NF*Rate^2*CorBinWidth;
end

%----------------------------------------------------------------------------
function Y = ApplyNorm(Y, DriesNorm)

if ~all(Y == 0), Y = Y/DriesNorm;
else, Y = ones(size(Y)); end

%----------------------------------------------------------------------------
function DisplayCorFncs(CorFncs, RefRow, Props)


%Reorganize information ... 
[Lag, NormCo, LagAtMax, MaxNorm] = DecomposeAndScaleCorFncs(CorFncs, Props);
[XRng, XTicks] = GetXLim(Lag, Props.corxrange, Props.corxstep); 
YRng = GetYLim(NormCo);
[IDStr, CaptionStr] = CreateInfoStr(CorFncs);

%next paragraph was added by TF, 07/09/2005 and 14/09/2005
if (~isnan(CorFncs(1).ds1.iseqn))&(~isnan(CorFncs(1).ds1.iseqp))
    difcor='yes';
else
    difcor='no';
end
try
    g=num2str(getCFList(CorFncs)); %try-catch used to handle fibers for which there is no thr-curve
catch
    g='(no cf available)';
end
IDStr = [IDStr ' - CF=' g ' Hz - difcor:' difcor];

%Create table with correlogram information ...
DispFNames = {'ds1.filename', 'ds1.iseqp', 'ds1.seqidp', ...
            'ds1.isubseqp', 'ds1.subseqvalp', 'ds1.subsequnitp', ...
            'ds1.iseqn', 'ds1.seqidn', ...
            'ds1.isubseqn', 'ds1.subseqvaln', 'ds1.subsequnitn', ...
            'ds1.discernvalue', ...
            'ds2.filename', 'ds2.iseqp', 'ds2.seqidp', ...
            'ds2.isubseqp', 'ds2.subseqvalp', 'ds2.subsequnitp', ...
            'ds2.iseqn', 'ds2.seqidn', ...
            'ds2.isubseqn', 'ds2.subseqvaln', 'ds2.subsequnitn', ...
            'ds2.discernvalue'};
if ~isempty(Props.rightyexpr), DispFNames = [DispFNames, {'ds2.rightyvalue'}]; end
%structview(CorFncs, 'titletxt', CaptionStr, ...
%        'fields', DispFNames, 'indexrow', 'on');
%Creating figure ...
FigHdl = figure('Name', CaptionStr, ...
    'NumberTitle', 'off', ...
    'Units', 'normalized', ...
    'OuterPosition', [0 0.025 1 0.975], ... %Maximize figure (not in the MS Windows style!) ...
    'PaperType', 'A4', ...
    'PaperPositionMode', 'manual', ...
    'PaperUnits', 'normalized', ...
    'PaperPosition', [0.05 0.05 0.90 0.90], ...
    'PaperOrientation', 'portrait');
%Position for axes-object(s) ...
Pos = [0.10, 0.10, 0.80, 0.80];

%Plot right ordinate if requested ...
if ~isempty(Props.rightyexpr), CreateRightOrdinate(CorFncs, Pos, YRng, Props); end

%Creating axes-object for actual correlograms ...
AxHdl = axes('Position', Pos, 'Box', 'off', 'TickDir', 'out', 'XLim', XRng, ...
    'XTick', XTicks, 'YLim', YRng);

if ~isempty(Props.rightyexpr), set(AxHdl, 'Color', 'none'); end
%Plotting fysiological ITD as yellow rectangle ...
if any(strcmpi(Props.plotfysitd, {'yes', 'inv'})),
    PlotFysITDRange(XRng, YRng, Props.fysitdrange, Props.plotfysitd); 
end 

%Plot vertical line at zero lag ...
PlotVerLine(YRng, 0);

%Plot unitbox if requested ...
if strcmpi(Props.plotunitbox, 'yes'), 
    PlotUnitBox(XRng, YRng, Props.normcoratio); 
end

%Plotting actual correlograms ...
LnHdls = line(Lag, NormCo, 'LineStyle', '-', 'Marker', 'none', 'tag', 'corfncs');

if ~isnan(RefRow), set(LnHdls(RefRow), 'LineWidth', 1.5); end
%Plotting dots on primary peaks and on secondary peaks if requested ...
if strcmpi(Props.plotprimpeaks, 'yes'),
    line(LagAtMax(:, 2), MaxNorm(:, 2), 'LineStyle', 'none', 'Marker', 'o', ...
        'Color', 'k','MarkerFace', [1 1 1], 'tag', 'primpeaks'); 
end
if strcmpi(Props.plotsecpeaks, 'yes'), 
    line(LagAtMax(:, 1), MaxNorm(:, 1), 'LineStyle', 'none', 'Marker', 'v', ...
        'Color', 'k','MarkerFace', [1 1 1], 'tag', 'leftsecpeaks'); 
    line(LagAtMax(:, 3), MaxNorm(:, 3), 'LineStyle', 'none', 'Marker', '^', ...
        'Color', 'k','MarkerFace', [1 1 1], 'tag', 'rightsecpeaks'); 
end
%Add labels and title ...
title(IDStr, 'FontSize', 12);
xlabel('Delay (ms)');
if ~isempty(Props.discernfieldunit), 
    YLblStr = sprintf('%s (%s)', Props.discernfieldlabel, Props.discernfieldunit);
else, YLblStr = Props.discernfieldlabel; end
ylabel(YLblStr);

%----------------------------------------------------------------------------
function [IDStr, CaptionStr] = CreateInfoStr(CorFncs)

if ~isnan(CorFncs(1).ds1.iseqp) & ~isnan(CorFncs(1).ds1.iseqn),
    IDStr = sprintf('Ref.Fiber A+[%s <%s>(%.1f %s)]/A-[<%s>(%.1f %s)]', ...
        upper(CorFncs(1).ds1.filename), ...
        CorFncs(1).ds1.seqidp, CorFncs(1).ds1.subseqvalp, CorFncs(1).ds1.subsequnitp, ...
        CorFncs(1).ds1.seqidn, CorFncs(1).ds1.subseqvaln, CorFncs(1).ds1.subsequnitn);
elseif ~isnan(CorFncs(1).ds1.iseqp),
    IDStr = sprintf('Ref.Fiber A+[%s <%s>(%.1f %s)]', ...
        upper(CorFncs(1).ds1.filename), ...
        CorFncs(1).ds1.seqidp, CorFncs(1).ds1.subseqvalp, CorFncs(1).ds1.subsequnitp);
else,
    IDStr = sprintf('Ref.Fiber A-[%s <%s>(%.1f %s)]', ...
        upper(CorFncs(1).ds1.filename), ...
        CorFncs(1).ds1.seqidn, CorFncs(1).ds1.subseqvaln, CorFncs(1).ds1.subsequnitn);
end
CaptionStr = sprintf('%s: %s', upper(mfilename), IDStr);

%----------------------------------------------------------------------------
function AxHdl = CreateRightOrdinate(CorFncs, Pos, YRng, Props)

YValues = sort(structfield(CorFncs, 'ds2.discernvalue'));
YLabels = num2str(sort(structfield(CorFncs, 'ds2.rightyvalue')));
%Create axes-object for right ordinate ...
AxHdl = axes('Position', Pos, 'TickDir', 'out', 'YAxisLocation', 'right', ...
    'XTick', [], 'XTickLabel', '', 'YLim', YRng, 'YTick', YValues, ...
    'YTickLabel', YLabels);
%Add label ...
if ~isempty(Props.rightyunit), 
    YLblStr = sprintf('%s (%s)', Props.rightylabel, Props.rightyunit);
else, YLblStr = Props.rightylabel; end
ylabel(YLblStr);

%----------------------------------------------------------------------------
function [Lag, NormCo, LagAtMax, MaxNorm] = DecomposeAndScaleCorFncs(CorFncs, Props)

%Decompose ...
[Data, FNames] = destruct(CorFncs);
CorType = Data(:, find(ismember(FNames, 'cortype')));
Lag = Data{1, find(ismember(FNames, 'lag'))};
NormCo = cat(1, Data{:, find(ismember(FNames, 'normco'))});
LagAtMax(:, [2 1 3]) = [cat(1, Data{:, find(ismember(FNames, 'primpeak.delay'))}), ...
        cat(1, Data{:, find(ismember(FNames, 'secpeaks.delay'))})];
MaxNorm(:, [2 1 3]) = [cat(1, Data{:, find(ismember(FNames, 'primpeak.normmagn'))}), ...
        cat(1, Data{:, find(ismember(FNames, 'secpeaks.normmagn'))})];
LeftYunits = cat(1, Data{:, find(ismember(FNames, 'ds2.discernvalue'))});

%Remove asymptote of one from SCCs/SACs ...
idx = find(strcmpi(CorType, 'cor'));

%TF 08/09/2005: als vorige lijn idx = find(strcmpi(CorType, 'cor')|strcmpi(CorType,'')); wordt, is de waterfallplot goed gestaggered
%voor Lists met NaN voor iseqp of iseqn

[NormCo(idx, :), MaxNorm(idx, :)] = deal(NormCo(idx, :)-1, MaxNorm(idx, :)-1); 

%Scale ...
N = size(NormCo, 2);
NormCo  = NormCo*Props.normcoratio + repmat(LeftYunits, 1, N);
MaxNorm = MaxNorm*Props.normcoratio + repmat(LeftYunits, 1, 3);

%----------------------------------------------------------------------------
function [XRng, XTicks] = GetXLim(Values, Range, Step)

Margin = 0.00;
 
if isinf(Range(1)), MinVal = min(Values(:))*(1-Margin); else MinVal = Range(1); end
if isinf(Range(2)), MaxVal = max(Values(:))*(1+Margin); else MaxVal = Range(2); end
XRng   = [MinVal, MaxVal];
XTicks = MinVal:Step:MaxVal;

%----------------------------------------------------------------------------
function YRng = GetYLim(Values)

Margin = 0.05;

YRng = [min(Values(:))*(1-Margin), max(Values(:))*(1+Margin)];

%----------------------------------------------------------------------------
function PlotUnitBox(XRng, YRng, NormCoRatio)

%Calculate sizes of current axis ...
Xsize = abs(diff(XRng)); Ysize = abs(diff(YRng));

%Find coordinates of lower left corner ...
[Xllc, Yllc] = deal(XRng(1) + 0.025*Xsize, YRng(1) + 0.025*Ysize);
%Find width and height of box ...
[Width, Height] = deal(0.005*Xsize, 1*NormCoRatio);

%Plot unitbox ...
rectangle('Position', [Xllc, Yllc, Width, Height], 'EdgeColor', 'k', ...
    'FaceColor', [1 1 1], 'LineStyle', '-');
rectangle('Position', [Xllc, Yllc, Width, Height/2], 'EdgeColor', 'k', ...
    'FaceColor', [0 0 0], 'LineStyle', '-');

%Plot legend ...
text(Xllc+Width+0.0005*Xsize, Yllc, '0.0', 'fontsize', 5, ...
    'fontweight', 'light');
text(Xllc+Width+0.0005*Xsize, Yllc+Height, '1.0', 'fontsize', 5, ...
    'fontweight', 'light');

%----------------------------------------------------------------------------
function PlotFysITDRange(XRng, YRng, FysRng, Type)

if strcmpi(Type, 'inv'), %Create inverted version ...
    patch([XRng([1 1]), FysRng([1 1])], YRng([1 2 2 1]), [1 1 0.75], ...
        'EdgeColor', [1 1 0.75], 'FaceColor', [1 1 0.75]);
    patch([FysRng([2 2]), XRng([2 2])], YRng([1 2 2 1]), [1 1 0.75], ...
        'EdgeColor', [1 1 0.75], 'FaceColor', [1 1 0.75]);
else, %Create normal version ...   
    patch(FysRng([1 2 2 1]), YRng([1 1 2 2]), [1 1 0.75], ...
        'EdgeColor', [1 1 0.75], 'FaceColor', [1 1 0.75]);
end
PlotVerLine(YRng, FysRng(1));
PlotVerLine(YRng, FysRng(2));

%----------------------------------------------------------------------------
function PlotVerLine(YRng, ConstantX)

line(ConstantX([1 1]), YRng, 'Color', 'k', 'LineStyle', ':');

%----------------------------------------------------------------------------
%function added by TF (07/09/2005), for smoothing
function C = smoothCor(C, N)

s=size(C);

for i=1:s(1)
    C(i,:) = runav(C(i,:), N, 0);
end

%----------------------------------------------------------------------------
%function added by TF (09/09/2005), to spline
function [Lag, NrOfCo, NormCo] = splineCor(lag, nrofco, normco, rfactor)

nlag = numel(lag); steplag = abs(lag(2)-lag(1));
stepLag = steplag/rfactor;

%compute the new lag-values
Lag=zeros((rfactor*nlag)-(rfactor-1),1);
for i=1:numel(Lag)
    Lag(i) = lag(1) + (i-1)*stepLag;    
end

NrOfCo = zeros(size(nrofco,1), numel(Lag));
NormCo = zeros(size(nrofco,1), numel(Lag));

for i=1:size(nrofco,1)
    NrOfCo(i,:) = (spline(lag, nrofco(i,:), Lag))';
    NormCo(i,:) = (spline(lag, normco(i,:), Lag))';
end

Lag=Lag';

%----------------------------------------------------------------------------