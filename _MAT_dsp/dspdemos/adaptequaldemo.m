%% Equalization in Digital Communications 
% This example shows how to apply adaptive filters to channel equalization
% in digital communications.
%
% Author(s): Scott C. Douglas
% Copyright 1999-2012 The MathWorks, Inc.


%% Introduction
% Channel equalization is a simple way of mitigating the detrimental
% effects caused by a frequency-selective and/or dispersive communication
% link between sender and receiver.  For this example, all signals
% are assumed to have a digital baseband representation.  During the
% training phase of channel equalization, a digital signal s[n] that is
% known to both the transmitter and receiver is sent by the transmitter to
% the receiver. The received signal x[n] contains two signals:
%        the signal s[n] filtered by the channel impulse response, and
%        an unknown broadband noise signal v[n].
% The goal is to filter x[n] to remove the inter-symbol interference (ISI)
% caused by the dispersive channel and to minimize the effect of the
% additive noise v[n].  Ideally, the output signal would closely follow a
% delayed version of the transmitted signal s[n].  

%% Transmitted Input Signal
%
% A digital signal carries information through its discrete structure.
% There are several common baseband signaling methods.  We shall use a
% 16-QAM complex-valued symbol set, in which the input signal takes one of
% sixteen different values given by all possible combinations of {-3, -1,
% 1, 3} + j*{-3, -1, 1, 3}, where j = sqrt(-1).  Let's generate a sequence
% of 5000 such symbols, where each one is equiprobable.

ntr = 5000;
j = sqrt(-1);
s = sign(randn(ntr,1)).*(2+sign(randn(ntr,1)))+...
    j*sign(randn(ntr,1)).*(2+sign(randn(ntr,1)));
Hs = dsp.SignalSource(s,'SamplesPerFrame',1000);
plot(s,'o');
axis([-4 4 -4 4]); 
axis('square');
xlabel('Re\{s(n)\}');
ylabel('Im\{s(n)\}');
title('Input signal constellation');

%% Transmission Channel
%
% The transmission channel is defined by the channel impulse response and
% the noise characteristics.  We shall choose a particular channel that
% exhibits both frequency selectivity and dispersion. The noise variance is
% chosen so that the received signal-to-noise ratio is 30 dB.

b = exp(j*pi/5)*[0.2 0.7 0.9];
a = [1 -0.7 0.4];
% Transmission channel filter
channel = dsp.BiquadFilter('SOSMatrix',[b,a]);
% Impulse response
hFV = fvtool(channel,'Analysis','impulse','Color','White');
legend(hFV, 'Transmission channel');
%%

% Frequency response
set(hFV, 'Analysis', 'freq')

%% Received Signal 
%
% The received signal x[n] is generated by the transmitted signal s[n]
% filtered by the channel impulse response with additive noise v[n]. We
% shall assume a complex Gaussian noise signal for the additive noise.

sig = sqrt(1/16*(4*18+8*10+4*2))/sqrt(1000)*norm(impz(channel));
v = sig*(randn(ntr,1) + j*randn(ntr,1))/sqrt(2);
x = step(channel,s) + v;
Hx = dsp.SignalSource(x,'SamplesPerFrame',Hs.SamplesPerFrame);
plot(x,'.');
xlabel('Re\{x[n]\}');
ylabel('Im\{x[n]\}');
axis([-40 40 -40 40]);
axis('square');
title('Received signal x[n]');
set(gcf, 'Color', [1 1 1])

%%  Training Signal
%  
% The training signal is a shifted version of the original transmitted
% signal s[n].  This signal would be known to both the transmitter and
% receiver.  

D = 10;
Hd = dsp.Delay(D);

%% Trained Equalization
% 
% To obtain the fastest convergence, we shall use the conventional version
% of a recursive least-squares estimator.  Only the first 2000 samples are
% used for training.  The output signal constellation shows clusters of
% values centered on the sixteen different symbol values--an indication
% that equalization has been achieved. 

P0 = 100*eye(20);
lam = 0.99;
h = dsp.RLSFilter(20,'ForgettingFactor',lam,'InitialInverseCovariance',P0);
hlog = dsp.SignalSink('BufferLength',2); % Store 2 frames (2000 samples)
for k = 1:2
    d = step(Hd,step(Hs));
    Rx = step(Hx);
    [y,e] = step(h,Rx,d);
    step(hlog,e);
    plot(y,'.');
    hold on
    xlabel('Re\{y[n]\}');
    ylabel('Im\{y[n]\}');
    axis([-5 5 -5 5]);
    axis('square');
    title('Equalized signal y[n]');
    set(gcf, 'Color', [1 1 1])
end

%% Training Error
%
% Plotting the squared magnitude of the error signal e[n], we see that
% convergence with the RLS algorithm is fast. It occurs in about 60 samples
% with the equalizer settings chosen.
hold off
ntrain = 1:1000;
semilogy(ntrain,abs(hlog.Buffer(ntrain)).^2);
xlabel('Number of iterations');
ylabel('|e[n]|^2')
title('Squared magnitude of the training errors');
set(gcf, 'Color', [1 1 1])

displayEndOfDemoMessage(mfilename)

